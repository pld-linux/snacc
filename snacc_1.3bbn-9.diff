--- snacc-1.3bbn.orig/debian/patches/configure.patch
+++ snacc-1.3bbn/debian/patches/configure.patch
@@ -0,0 +1,627 @@
+diff -uraN snacc-1.3bbn/configure.ac snacc-1.3bbn-debian/configure.ac
+--- snacc-1.3bbn/configure.ac	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3bbn-debian/configure.ac	2005-07-30 17:20:35.043753552 +0000
+@@ -0,0 +1,314 @@
++dnl Process this file with autoconf to produce a configure script.
++dnl ---
++dnl	$Log$
++dnl	Revision 1.3  2002/11/19 20:28:12  debacle
++dnl	libtool changes.
++dnl	
++dnl	Revision 1.2  2002/11/19 19:37:38  debacle
++dnl	Auto-tools stuff.
++dnl	
++dnl	Revision 1.1  2002/11/19 19:18:04  debacle
++dnl	New autoconf.
++dnl	
++dnl	Revision 1.13  1997/09/04 13:54:04  wan
++dnl	A little more portability
++dnl
++dnl	Revision 1.12  1997/02/28 13:39:35  wan
++dnl	Modifications collected for new version 1.3: Bug fixes, tk4.2.
++dnl
++dnl	Revision 1.11  1997/02/16 16:50:27  rj
++dnl	made return *this after calling abort()'' a compile time option.
++dnl
++dnl	Revision 1.10  1997/02/15 20:06:27  rj
++dnl	adjust to changed AC_TRY_COMPILE macro
++dnl
++dnl	Revision 1.9  1997/02/15 20:01:38  rj
++dnl	check whether the compiler supports volatile functions (and whether abort() is volatile).
++dnl
++dnl	Revision 1.8  1997/01/01 19:57:01  rj
++dnl	changes for autoconf version 2.12
++dnl
++dnl	Revision 1.7  1995/09/07  18:36:47  rj
++dnl	psbook and psnup are looked for (used by .../doc/makefile)
++dnl
++dnl	Revision 1.6  1995/07/24  14:44:47  rj
++dnl	don't use gcc/g++ with -pipe, compiling some files may exceed virtual memory.
++dnl
++dnl	look for tclsh(1). tcl-lib uses it to construct the tclIndex file. don't look for Tcl/Tk if the tclsh is absent.
++dnl
++dnl	look for patch(1). the c-lib uses it to patch tbl.h.
++dnl
++dnl	search for tree-3.6's libtktree.a and set TREELIBS in .../makehead accordingly.
++dnl
++dnl	check for memset(3), memcpy(3) and memcmp(3). .../snacc.h reverts to bzero(3), bcopy(3) and bcmp(3) if necessary.
++dnl
++dnl	Revision 1.5  1995/02/20  11:18:41  rj
++dnl	cpp switch HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS added.
++dnl	check for isinf(3) and finite(3) added.
++dnl
++dnl	Revision 1.4  1995/02/17  15:15:44  rj
++dnl	hack to let makedepend find .h files the way gcc does.
++dnl
++dnl	Revision 1.3  1995/02/17  14:26:40  rj
++dnl	adjustments for autoconf 2.x
++dnl
++dnl	Revision 1.2  1994/10/08  04:29:37  rj
++dnl	search for Tcl/Tk
++dnl
++dnl	Revision 1.1  1994/09/01  00:51:22  rj
++dnl	first check-in (new file).
++dnl
++AC_INIT( compiler/core/snacc.c)
++AC_REVISION($Revision$)
++AM_INIT_AUTOMAKE(snacc, 1.3)
++AM_CONFIG_HEADER( config.h)
++dnl --- alternative programs:
++AC_PROG_MAKE_SET
++AC_PROG_CC
++AC_ISC_POSIX
++dnl if CDPATH is set, the configure script might fail
++unset CDPATH
++dnl if test -n "$GCC"; then
++dnl   saveCC="$CC"
++dnl   CC="$CC -pipe"
++dnl   AC_MSG_CHECKING( whether $saveCC takes -pipe)
++dnl   AC_TRY_LINK( , , [AC_MSG_RESULT( yes)], [AC_MSG_RESULT( no); CC="$saveCC"])
++dnl fi
++AC_PROG_GCC_TRADITIONAL
++AC_MSG_CHECKING( whether ANSI or K&R style C)
++AC_TRY_COMPILE([ ], [void *p; p = "test";], [
++AC_MSG_RESULT(ANSI)
++AC_DEFINE( __USE_ANSI_C__)
++], [
++AC_MSG_RESULT(K&R)
++])
++AC_PROG_CXX
++AC_LANG_CPLUSPLUS
++dnl if test -n "$GCC"; then
++dnl   saveCXX="$CXX"
++dnl   CXX="$CXX -pipe"
++dnl   AC_MSG_CHECKING( whether $saveCXX takes -pipe)
++dnl   AC_TRY_LINK( , , [AC_MSG_RESULT( yes)], [AC_MSG_RESULT( no);CC="$saveCC"])
++dnl fi
++AC_MSG_CHECKING( for bool built-in)
++AC_TRY_COMPILE( , bool b = false;, [AC_DEFINE( BOOL_BUILTIN) AC_MSG_RESULT( yes)], AC_MSG_RESULT( no))
++AC_MSG_CHECKING( for variable sized automatic arrays)
++AC_TRY_COMPILE( , changequote(<,>)int i = 42; char a[++i]; *a = i;changequote([,]), [AC_DEFINE( HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS) AC_MSG_RESULT( yes)], AC_MSG_RESULT( no))
++AC_MSG_CHECKING( for volatile functions)
++AC_TRY_COMPILE( , changequote(<,>)abort();changequote([,]), [AC_MSG_RESULT( yes)], [AC_DEFINE( COMPILER_WITHOUT_VOLATILE_FUNCTIONS) SNACC_NOVOLAT=-novolat; AC_SUBST( SNACC_NOVOLAT) AC_MSG_RESULT( no)])
++AC_LANG_C
++AM_PROG_LEX
++case "$LEX" in
++  lex)
++    LFLAGS="-Nc10000"
++  ;;
++  flex)
++    CFLAGS="$CFLAGS -DFLEX_IN_USE"
++esac
++AC_SUBST( LFLAGS)
++AC_SUBST( CFLAGS)
++# the boot strapping code in .../c-lib/ needs patch:
++AC_CHECK_PROGS( PATCH, patch, false)
++AC_PROG_YACC
++AC_PROG_LN_S
++AC_PROG_INSTALL
++dnl --- header files:
++AC_HEADER_TIME
++AC_HEADER_DIRENT
++AC_TYPE_SIZE_T
++AC_TYPE_UID_T
++AC_HEADER_STDC
++AC_CHECK_HEADERS( unistd.h memory.h string.h malloc.h fcntl.h)
++AC_FUNC_VPRINTF
++dnl --- system and compiler characteristics:
++AC_C_CONST
++AC_C_BIGENDIAN
++AC_CHECK_SIZEOF(short, 2)
++AC_CHECK_SIZEOF(int, 4)
++AC_CHECK_SIZEOF(long, 4)
++AC_CHECK_SIZEOF(double, 8)
++AC_CHECK_LIB( m, sin)
++AC_CHECK_FUNCS( isinf finite)
++AC_CHECK_FUNCS( memset memcpy memcmp)
++dnl ---
++AC_PATH_X
++AC_PATH_XTRA
++AC_CHECK_PROGS( TCLSH, tclsh, false)
++if test "$TCLSH" != false && test "x$no_x" != "xyes"; then
++  AC_CHECK_HEADER(
++    tcl.h,
++    [AC_CHECK_LIB( ld, ldopen, TCLOTHERLIBS=-lld)
++    AC_CHECK_LIB(
++      tcl,
++      Tcl_CreateInterp,
++      [saveCFLAGS="$CFLAGS"
++      CFLAGS="$CFLAGS $X_CFLAGS"
++      AC_CHECK_LIB(
++	tk,
++	Tk_CreateWindow,
++	[AC_DEFINE( HAVE_TCL)
++	TCLLIBS="-ltk -ltcl $TCLOTHERLIBS"
++	CXXTCLDIR="tcl"
++	TCLDIRS="tcl-lib tcl-asn tcl-example"
++	AC_LANG_CPLUSPLUS
++	AC_CHECK_LIB(
++	  TkTree,
++	  Tree_Init,
++	  [TREELIBS="-lTkTree"],
++	  [AC_MSG_RESULT( [tcl/tk libs found, but tree widget is missing])],
++	  -lTkTree -ltk -ltcl $TCLOTHERLIBS $X_LIBS $X_PRE_LIBS -lX11 $X_EXTRA_LIBS)
++	AC_LANG_C],
++	[AC_MSG_RESULT( [tcl lib found, but tk lib is missing])],
++	-ltcl $TCLOTHERLIBS $X_LIBS $X_PRE_LIBS -lX11 $X_EXTRA_LIBS)
++      CFLAGS="$saveCFLAGS"],
++      [AC_MSG_RESULT( [tcl library not found])],
++      $TCLOTHERLIBS -lm)])
++fi
++AC_SUBST( CXXTCLDIR)
++AC_SUBST( TCLDIRS)
++AC_SUBST( TCLLIBS)
++AC_SUBST( TREELIBS)
++dnl ---
++AC_CHECK_PROGS( LATEX, latex, false)
++AC_CHECK_PROGS( BIBTEX, bibtex, false)
++AC_CHECK_PROGS( DVIPS, dvips, false)
++AC_CHECK_PROGS( DETEX, detex2 detex, false)
++AC_CHECK_PROGS( PSPREVIEW, ghostview gs, true)
++AC_CHECK_PROGS( PSBOOK, psbook, false)
++AC_CHECK_PROGS( PSNUP, psnup, false)
++AC_CHECK_PROGS( SPELL, ispell spell, spell)
++dnl ---
++
++dnl Configure for libtool.
++AC_PROG_LIBTOOL
++
++dnl Generate the C library build directories.
++linked_files=`cd c-lib/src && ls *.c`
++for dir in Cebuf ebuf mbuf sbuf tbl; do
++  if test -d c-lib/$dir; then :; else
++    echo creating c-lib/$dir
++    mkdir c-lib/$dir
++  fi
++  (cd c-lib/$dir && touch Makefile.am && rm -f Makefile.in $linked_files && $LN_S ../src/*.c . )
++  sed_code="-e s/libasn1cbuf/libasn1c$dir/g"
++  case $dir in
++  Cebuf) 
++    (cd c-lib/$dir && rm -f asn-useful.c asn-useful.h tbl.c tbl.h && $LN_S ../boot/asn* ../boot/tbl* .)
++    sed_code="$sed_code -e s/^.*asn-useful\.c:/neverA:/ -e s/^.*tbl\.c:/neverB:/"
++    BUFFLAGS="-DCOMPILER -DUSE_NIBBLE_MEMORY=0 -DUSE_EXP_BUF -I\$(top_srcdir)/compiler/core"
++    ;;
++  ebuf) BUFFLAGS="-DUSE_EXP_BUF" ;;
++  mbuf) BUFFLAGS="-DUSE_MIN_BUF" ;;
++  sbuf) BUFFLAGS="-DUSE_SBUF" ;;
++  tbl) BUFFLAGS="-DUSE_GEN_BUF -DTTBL" ;;
++  esac
++  echo "BUFFLAGS = $BUFFLAGS" >> c-lib/$dir/Makefile.in
++  eval sed $sed_code < c-lib/src/Makefile.in >> c-lib/$dir/Makefile.in
++done
++
++dnl Generate the C++ and Tcl library build directories.
++linked_files=`cd c++-lib/src && ls *.c *.C`
++for dir in c++ tcl; do
++  if test -d c++-lib/$dir; then :; else
++    echo creating c++-lib/$dir
++    mkdir c++-lib/$dir
++  fi
++  (cd c++-lib/$dir && touch Makefile.am && rm -f Makefile.in $linked_files && $LN_S ../src/*.c ../src/*.C .)
++  sed_code="-e s/libasn1cxxtcl/libasn1$dir/g"
++  case $dir in
++  c++) BUFFLAGS="-DMETA=0" sed_code="$sed_code -e s/noinst/lib/g";;
++  tcl) BUFFLAGS="-DTCL" sed_code="$sed_code -e s/noinst/lib/g";;
++  esac
++  echo "BUFFLAGS = $BUFFLAGS" >> c++-lib/$dir/Makefile.in
++  eval sed $sed_code < c++-lib/src/Makefile.in >> c++-lib/$dir/Makefile.in
++done  
++
++dnl Generate snaccconfig.h.  The whether-to-generate logic is cribbed
++dnl from glib-1.2.1's configure.in.  See that file for an explanation.
++AC_OUTPUT_COMMANDS([
++          
++## Generate `snaccconfig.h' in two 
++## cases:
++## 1. `config.status' is run either explicitly, or via configure.
++##     Esp. not when it is run in `Makefile' to generate makefiles and
++##     config.h
++## 2. CONFIG_OTHER is set explicitly
++##
++## Case 1 is difficult.  We know that `automake' sets one of
++## CONFIG_FILES or CONFIG_HEADERS to empty.  This heuristic works
++## only when AM_CONFIG_HEADER is set, however.
++
++case "x$CONFIG_OTHER" in
++*snaccconfig.h) gen_snaccconfig_h=yes
++;;
++esac
++if test -n "${CONFIG_FILES}" && test -n "${CONFIG_HEADERS}"; then
++  # Both CONFIG_FILES and CONFIG_HEADERS are non-empty ==> Case 1
++  if test "x${CONFIG_OTHER}" = x; then
++    gen_snaccconfig_h=yes
++  fi
++fi
++
++## If we're generating snaccconfig.h:
++## FIXME - currently, snaccconfig.h is just the normal
++## config.h wrapped.  this is because the user include
++## files use the normal config.h symbol names, and I 
++## haven't changed those yet.
++if test "x$gen_snaccconfig_h" = xyes; then
++  outfile=snaccconfig.h
++  echo creating $outfile
++  cat <<SNACCEOF > ${outfile}-tmp
++/* snaccconfig.h
++ * 
++ * This is an automatically generated file - please modify 'configure.in'.
++ */
++
++#ifndef _SNACCCONFIG_H
++#define _SNACCCONFIG_H
++
++SNACCEOF
++  egrep -v 'PACKAGE|VERSION' config.h >> ${outfile}-tmp
++  cat <<SNACCEOF >> ${outfile}-tmp
++
++#endif /* !_SNACCCONFIG_H */
++SNACCEOF
++  if cmp -s ${outfile}-tmp $outfile; then
++    echo $outfile is unchanged
++    rm -f ${outfile}-tmp
++  else
++    mv ${outfile}-tmp ${outfile}
++  fi
++fi
++])
++
++dnl Writes files.
++AC_OUTPUT(Makefile
++          compiler/Makefile
++          compiler/back-ends/c++-gen/Makefile
++          compiler/back-ends/c-gen/Makefile
++          compiler/back-ends/idl-gen/Makefile
++          compiler/back-ends/Makefile
++          compiler/core/Makefile
++	  c-lib/Makefile
++	  c-lib/inc/Makefile
++	  c-lib/src/Makefile
++	  c-lib/Cebuf/Makefile
++	  c-lib/ebuf/Makefile
++	  c-lib/mbuf/Makefile
++	  c-lib/sbuf/Makefile
++	  c-lib/tbl/Makefile
++	  c++-lib/Makefile
++	  c++-lib/inc/Makefile
++	  c++-lib/src/Makefile
++	  c++-lib/c++/Makefile
++	  c++-lib/tcl/Makefile
++          asn1specs/Makefile
++          tbl-tools/berdecode/Makefile
++          tbl-tools/mkchdr/Makefile
++          tbl-tools/ptbl/Makefile
++          tbl-tools/pval/Makefile
++          tbl-tools/Makefile
++          doc/Makefile
++          snacc-config,
++[if test -f snacc-config; then chmod +x snacc-config; fi])
++dnl --- finis
+diff -uraN snacc-1.3bbn/configure.in snacc-1.3bbn-debian/configure.in
+--- snacc-1.3bbn/configure.in	2005-07-30 20:06:02.703761472 +0000
++++ snacc-1.3bbn-debian/configure.in	1970-01-01 00:00:00.000000000 +0000
+@@ -1,305 +0,0 @@
+-dnl Process this file with autoconf to produce a configure script.
+-dnl ---
+-dnl	$Log$
+-dnl	Revision 1.13  1997/09/04 13:54:04  wan
+-dnl	A little more portability
+-dnl
+-dnl	Revision 1.12  1997/02/28 13:39:35  wan
+-dnl	Modifications collected for new version 1.3: Bug fixes, tk4.2.
+-dnl
+-dnl	Revision 1.11  1997/02/16 16:50:27  rj
+-dnl	made return *this after calling abort()'' a compile time option.
+-dnl
+-dnl	Revision 1.10  1997/02/15 20:06:27  rj
+-dnl	adjust to changed AC_TRY_COMPILE macro
+-dnl
+-dnl	Revision 1.9  1997/02/15 20:01:38  rj
+-dnl	check whether the compiler supports volatile functions (and whether abort() is volatile).
+-dnl
+-dnl	Revision 1.8  1997/01/01 19:57:01  rj
+-dnl	changes for autoconf version 2.12
+-dnl
+-dnl	Revision 1.7  1995/09/07  18:36:47  rj
+-dnl	psbook and psnup are looked for (used by .../doc/makefile)
+-dnl
+-dnl	Revision 1.6  1995/07/24  14:44:47  rj
+-dnl	don't use gcc/g++ with -pipe, compiling some files may exceed virtual memory.
+-dnl
+-dnl	look for tclsh(1). tcl-lib uses it to construct the tclIndex file. don't look for Tcl/Tk if the tclsh is absent.
+-dnl
+-dnl	look for patch(1). the c-lib uses it to patch tbl.h.
+-dnl
+-dnl	search for tree-3.6's libtktree.a and set TREELIBS in .../makehead accordingly.
+-dnl
+-dnl	check for memset(3), memcpy(3) and memcmp(3). .../snacc.h reverts to bzero(3), bcopy(3) and bcmp(3) if necessary.
+-dnl
+-dnl	Revision 1.5  1995/02/20  11:18:41  rj
+-dnl	cpp switch HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS added.
+-dnl	check for isinf(3) and finite(3) added.
+-dnl
+-dnl	Revision 1.4  1995/02/17  15:15:44  rj
+-dnl	hack to let makedepend find .h files the way gcc does.
+-dnl
+-dnl	Revision 1.3  1995/02/17  14:26:40  rj
+-dnl	adjustments for autoconf 2.x
+-dnl
+-dnl	Revision 1.2  1994/10/08  04:29:37  rj
+-dnl	search for Tcl/Tk
+-dnl
+-dnl	Revision 1.1  1994/09/01  00:51:22  rj
+-dnl	first check-in (new file).
+-dnl
+-AC_INIT( compiler/core/snacc.c)
+-AC_REVISION($Revision$)
+-AM_INIT_AUTOMAKE(snacc, 1.3)
+-AM_CONFIG_HEADER( config.h)
+-dnl --- alternative programs:
+-AC_PROG_MAKE_SET
+-AC_PROG_CC
+-AC_ISC_POSIX
+-if test -n "$GCC"; then
+-dnl   saveCC="$CC"
+-dnl   CC="$CC -pipe"
+-dnl   AC_MSG_CHECKING( whether $saveCC takes -pipe)
+-dnl   AC_TRY_LINK( , , [AC_MSG_RESULT( yes)], [AC_MSG_RESULT( no); CC="$saveCC"])
+-fi
+-AC_PROG_GCC_TRADITIONAL
+-AC_MSG_CHECKING( whether ANSI or K&R style C)
+-AC_TRY_COMPILE([ ], [void *p; p = "test";], [
+-AC_MSG_RESULT(ANSI)
+-AC_DEFINE( __USE_ANSI_C__)
+-], [
+-AC_MSG_RESULT(K&R)
+-])
+-AC_PROG_CXX
+-AC_LANG_CPLUSPLUS
+-dnl if test -n "$GCC"; then
+-dnl   saveCXX="$CXX"
+-dnl   CXX="$CXX -pipe"
+-dnl   AC_MSG_CHECKING( whether $saveCXX takes -pipe)
+-dnl   AC_TRY_LINK( , , [AC_MSG_RESULT( yes)], [AC_MSG_RESULT( no);CC="$saveCC"])
+-dnl fi
+-AC_MSG_CHECKING( for bool built-in)
+-AC_TRY_COMPILE( , bool b = false;, [AC_DEFINE( BOOL_BUILTIN) AC_MSG_RESULT( yes)], AC_MSG_RESULT( no))
+-AC_MSG_CHECKING( for variable sized automatic arrays)
+-AC_TRY_COMPILE( , changequote(<,>)int i = 42; char a[++i]; *a = i;changequote([,]), [AC_DEFINE( HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS) AC_MSG_RESULT( yes)], AC_MSG_RESULT( no))
+-AC_MSG_CHECKING( for volatile functions)
+-AC_TRY_COMPILE( , changequote(<,>)abort();changequote([,]), [AC_MSG_RESULT( yes)], [AC_DEFINE( COMPILER_WITHOUT_VOLATILE_FUNCTIONS) SNACC_NOVOLAT=-novolat; AC_SUBST( SNACC_NOVOLAT) AC_MSG_RESULT( no)])
+-AC_LANG_C
+-AM_PROG_LEX
+-case "$LEX" in
+-  lex)
+-    LFLAGS="-Nc10000"
+-  ;;
+-  flex)
+-    CFLAGS="$CFLAGS -DFLEX_IN_USE"
+-esac
+-AC_SUBST( LFLAGS)
+-AC_SUBST( CFLAGS)
+-# the boot strapping code in .../c-lib/ needs patch:
+-AC_CHECK_PROGS( PATCH, patch, false)
+-AC_PROG_YACC
+-AC_PROG_LN_S
+-AC_PROG_INSTALL
+-dnl --- header files:
+-AC_HEADER_TIME
+-AC_HEADER_DIRENT
+-AC_TYPE_SIZE_T
+-AC_TYPE_UID_T
+-AC_HEADER_STDC
+-AC_CHECK_HEADERS( unistd.h memory.h string.h malloc.h fcntl.h)
+-AC_FUNC_VPRINTF
+-dnl --- system and compiler characteristics:
+-AC_C_CONST
+-AC_C_BIGENDIAN
+-AC_CHECK_SIZEOF(short, 2)
+-AC_CHECK_SIZEOF(int, 4)
+-AC_CHECK_SIZEOF(long, 4)
+-AC_CHECK_SIZEOF(double, 8)
+-AC_CHECK_LIB( m, sin)
+-AC_CHECK_FUNCS( isinf finite)
+-AC_CHECK_FUNCS( memset memcpy memcmp)
+-dnl ---
+-AC_PATH_X
+-AC_PATH_XTRA
+-AC_CHECK_PROGS( TCLSH, tclsh, false)
+-if test "$TCLSH" != false && test "x$no_x" != "xyes"; then
+-  AC_CHECK_HEADER(
+-    tcl.h,
+-    [AC_CHECK_LIB( ld, ldopen, TCLOTHERLIBS=-lld)
+-    AC_CHECK_LIB(
+-      tcl,
+-      Tcl_CreateInterp,
+-      [saveCFLAGS="$CFLAGS"
+-      CFLAGS="$CFLAGS $X_CFLAGS"
+-      AC_CHECK_LIB(
+-	tk,
+-	Tk_CreateWindow,
+-	[AC_DEFINE( HAVE_TCL)
+-	TCLLIBS="-ltk -ltcl $TCLOTHERLIBS"
+-	CXXTCLDIR="tcl"
+-	TCLDIRS="tcl-lib tcl-asn tcl-example"
+-	AC_LANG_CPLUSPLUS
+-	AC_CHECK_LIB(
+-	  TkTree,
+-	  Tree_Init,
+-	  [TREELIBS="-lTkTree"],
+-	  [AC_MSG_RESULT( [tcl/tk libs found, but tree widget is missing])],
+-	  -lTkTree -ltk -ltcl $TCLOTHERLIBS $X_LIBS $X_PRE_LIBS -lX11 $X_EXTRA_LIBS)
+-	AC_LANG_C],
+-	[AC_MSG_RESULT( [tcl lib found, but tk lib is missing])],
+-	-ltcl $TCLOTHERLIBS $X_LIBS $X_PRE_LIBS -lX11 $X_EXTRA_LIBS)
+-      CFLAGS="$saveCFLAGS"],
+-      [AC_MSG_RESULT( [tcl library not found])],
+-      $TCLOTHERLIBS -lm)])
+-fi
+-AC_SUBST( CXXTCLDIR)
+-AC_SUBST( TCLDIRS)
+-AC_SUBST( TCLLIBS)
+-AC_SUBST( TREELIBS)
+-dnl ---
+-AC_CHECK_PROGS( LATEX, latex, false)
+-AC_CHECK_PROGS( BIBTEX, bibtex, false)
+-AC_CHECK_PROGS( DVIPS, dvips, false)
+-AC_CHECK_PROGS( DETEX, detex2 detex, false)
+-AC_CHECK_PROGS( PSPREVIEW, ghostview gs, true)
+-AC_CHECK_PROGS( PSBOOK, psbook, false)
+-AC_CHECK_PROGS( PSNUP, psnup, false)
+-AC_CHECK_PROGS( SPELL, ispell spell, spell)
+-dnl ---
+-
+-dnl Configure for libtool.
+-AM_PROG_LIBTOOL
+-LTLIBOBJS=`echo "$LIBOBJS" | sed 's/\.o/.lo/g'`
+-AC_SUBST(LTLIBOBJS)
+-
+-dnl Generate the C library build directories.
+-linked_files=`cd c-lib/src && ls *.c`
+-for dir in Cebuf ebuf mbuf sbuf tbl; do
+-  if test -d c-lib/$dir; then :; else
+-    echo creating c-lib/$dir
+-    mkdir c-lib/$dir
+-  fi
+-  (cd c-lib/$dir && touch Makefile.am && rm -f Makefile.in $linked_files && $LN_S ../src/*.c . )
+-  sed_code="-e s/libasn1cbuf/libasn1c$dir/g"
+-  case $dir in
+-  Cebuf) 
+-    (cd c-lib/$dir && rm -f asn-useful.c asn-useful.h tbl.c tbl.h && $LN_S ../boot/asn* ../boot/tbl* .)
+-    sed_code="$sed_code -e s/^.*asn-useful\.c:/neverA:/ -e s/^.*tbl\.c:/neverB:/"
+-    BUFFLAGS="-DCOMPILER -DUSE_NIBBLE_MEMORY=0 -DUSE_EXP_BUF -I\$(top_srcdir)/compiler/core"
+-    ;;
+-  ebuf) BUFFLAGS="-DUSE_EXP_BUF" ;;
+-  mbuf) BUFFLAGS="-DUSE_MIN_BUF" ;;
+-  sbuf) BUFFLAGS="-DUSE_SBUF" ;;
+-  tbl) BUFFLAGS="-DUSE_GEN_BUF -DTTBL" ;;
+-  esac
+-  echo "BUFFLAGS = $BUFFLAGS" >> c-lib/$dir/Makefile.in
+-  eval sed $sed_code < c-lib/src/Makefile.in >> c-lib/$dir/Makefile.in
+-done
+-
+-dnl Generate the C++ and Tcl library build directories.
+-linked_files=`cd c++-lib/src && ls *.c *.C`
+-for dir in c++ tcl; do
+-  if test -d c++-lib/$dir; then :; else
+-    echo creating c++-lib/$dir
+-    mkdir c++-lib/$dir
+-  fi
+-  (cd c++-lib/$dir && touch Makefile.am && rm -f Makefile.in $linked_files && $LN_S ../src/*.c ../src/*.C .)
+-  sed_code="-e s/libasn1cxxtcl/libasn1$dir/g"
+-  case $dir in
+-  c++) BUFFLAGS="-DMETA=0" sed_code="$sed_code -e s/noinst/lib/g";;
+-  tcl) BUFFLAGS="-DTCL" sed_code="$sed_code -e s/noinst/lib/g";;
+-  esac
+-  echo "BUFFLAGS = $BUFFLAGS" >> c++-lib/$dir/Makefile.in
+-  eval sed $sed_code < c++-lib/src/Makefile.in >> c++-lib/$dir/Makefile.in
+-done  
+-
+-dnl Generate snaccconfig.h.  The whether-to-generate logic is cribbed
+-dnl from glib-1.2.1's configure.in.  See that file for an explanation.
+-AC_OUTPUT_COMMANDS([
+-          
+-## Generate `snaccconfig.h' in two 
+-## cases:
+-## 1. `config.status' is run either explicitly, or via configure.
+-##     Esp. not when it is run in `Makefile' to generate makefiles and
+-##     config.h
+-## 2. CONFIG_OTHER is set explicitly
+-##
+-## Case 1 is difficult.  We know that `automake' sets one of
+-## CONFIG_FILES or CONFIG_HEADERS to empty.  This heuristic works
+-## only when AM_CONFIG_HEADER is set, however.
+-
+-case "x$CONFIG_OTHER" in
+-*snaccconfig.h) gen_snaccconfig_h=yes
+-;;
+-esac
+-if test -n "${CONFIG_FILES}" && test -n "${CONFIG_HEADERS}"; then
+-  # Both CONFIG_FILES and CONFIG_HEADERS are non-empty ==> Case 1
+-  if test "x${CONFIG_OTHER}" = x; then
+-    gen_snaccconfig_h=yes
+-  fi
+-fi
+-
+-## If we're generating snaccconfig.h:
+-## FIXME - currently, snaccconfig.h is just the normal
+-## config.h wrapped.  this is because the user include
+-## files use the normal config.h symbol names, and I 
+-## haven't changed those yet.
+-if test "x$gen_snaccconfig_h" = xyes; then
+-  outfile=snaccconfig.h
+-  echo creating $outfile
+-  cat <<SNACCEOF > ${outfile}-tmp
+-/* snaccconfig.h
+- * 
+- * This is an automatically generated file - please modify 'configure.in'.
+- */
+-
+-#ifndef _SNACCCONFIG_H
+-#define _SNACCCONFIG_H
+-
+-SNACCEOF
+-  egrep -v 'PACKAGE|VERSION' config.h >> ${outfile}-tmp
+-  cat <<SNACCEOF >> ${outfile}-tmp
+-
+-#endif /* !_SNACCCONFIG_H */
+-SNACCEOF
+-  if cmp -s ${outfile}-tmp $outfile; then
+-    echo $outfile is unchanged
+-    rm -f ${outfile}-tmp
+-  else
+-    mv ${outfile}-tmp ${outfile}
+-  fi
+-fi
+-])
+-
+-dnl Writes files.
+-AC_OUTPUT(Makefile
+-          compiler/Makefile
+-          compiler/back-ends/c++-gen/Makefile
+-          compiler/back-ends/c-gen/Makefile
+-          compiler/back-ends/idl-gen/Makefile
+-          compiler/back-ends/Makefile
+-          compiler/core/Makefile
+-	  c-lib/Makefile
+-	  c-lib/inc/Makefile
+-	  c-lib/src/Makefile
+-	  c-lib/Cebuf/Makefile
+-	  c-lib/ebuf/Makefile
+-	  c-lib/mbuf/Makefile
+-	  c-lib/sbuf/Makefile
+-	  c-lib/tbl/Makefile
+-	  c++-lib/Makefile
+-	  c++-lib/inc/Makefile
+-	  c++-lib/src/Makefile
+-	  c++-lib/c++/Makefile
+-	  c++-lib/tcl/Makefile
+-          asn1specs/Makefile
+-          tbl-tools/berdecode/Makefile
+-          tbl-tools/mkchdr/Makefile
+-          tbl-tools/ptbl/Makefile
+-          tbl-tools/pval/Makefile
+-          tbl-tools/Makefile
+-          doc/Makefile
+-          snacc-config,
+-[if test -f snacc-config; then chmod +x snacc-config; fi])
+-dnl --- finis
--- snacc-1.3bbn.orig/debian/patches/gcc.patch
+++ snacc-1.3bbn/debian/patches/gcc.patch
@@ -0,0 +1,936 @@
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-any.h snacc-1.3bbn/c++-lib/inc/asn-any.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-any.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-any.h	2005-07-30 19:22:42.514097072 +0000
+@@ -81,7 +81,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &) const;
++  void				Print (std::ostream &) const;
+ 
+ #if 0
+ #if TCL
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-bits.h snacc-1.3bbn/c++-lib/inc/asn-bits.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-bits.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-bits.h	2005-07-30 19:23:29.321981192 +0000
+@@ -105,7 +105,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &) const;
++  void				Print (std::ostream &) const;
+ 
+ #if META
+   static const AsnBitsTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-bool.h snacc-1.3bbn/c++-lib/inc/asn-bool.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-bool.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-bool.h	2005-07-30 19:23:45.319549192 +0000
+@@ -101,7 +101,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &) const;
++  void				Print (std::ostream &) const;
+ 
+ #if META
+   static const AsnBoolTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-config.h snacc-1.3bbn/c++-lib/inc/asn-config.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-config.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-config.h	2005-07-30 19:24:29.054900408 +0000
+@@ -49,7 +49,7 @@
+ #define _asn_config_h_
+ 
+ #include <ctype.h>  /* for isprint() in <<op on AsnOcts */
+-#include <iostream.h>
++#include <iostream>
+ #include <memory.h>
+ #include <string.h>
+ #include <setjmp.h>
+@@ -85,14 +85,14 @@
+  * Asn1Error (char *str)
+  *  - configure error handler
+  */
+-#define Asn1Error		cerr
++#define Asn1Error		std::cerr
+ 
+ 
+ /*
+  * Asn1Warning (char *str)  - configure warning mechanism
+  * (currently not called)
+  */
+-#define Asn1Warning		cerr
++#define Asn1Warning		std::cerr
+ 
+ 
+ /*
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-int.h snacc-1.3bbn/c++-lib/inc/asn-int.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-int.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-int.h	2005-07-30 19:24:45.421412320 +0000
+@@ -70,7 +70,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &os) const;
++  void				Print (std::ostream &os) const;
+ 
+ #if META
+   static const AsnIntTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-list.h snacc-1.3bbn/c++-lib/inc/asn-list.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-list.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-list.h	2005-07-30 19:25:10.914682616 +0000
+@@ -86,7 +86,7 @@
+ 				  last (NULL)
+ 				{}
+ 
+-  friend ostream		&operator << (ostream &os, AsnList &l);
++  friend std::ostream		&operator << (std::ostream &os, AsnList &l);
+ 
+   void				SetCurrElmt (unsigned long int index);
+   void				SetCurrToFirst()			{ curr = first; }
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-null.h snacc-1.3bbn/c++-lib/inc/asn-null.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-null.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-null.h	2005-07-30 19:25:26.432323576 +0000
+@@ -57,7 +57,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &os) const;
++  void				Print (std::ostream &os) const;
+ 
+ #if META
+   static const AsnNullTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-octs.h snacc-1.3bbn/c++-lib/inc/asn-octs.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-octs.h	2001-01-27 01:03:02.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-octs.h	2005-07-30 19:25:41.916969552 +0000
+@@ -108,7 +108,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &os) const;
++  void				Print (std::ostream &os) const;
+ 
+ #if META
+   static const AsnOctsTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-oid.h snacc-1.3bbn/c++-lib/inc/asn-oid.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-oid.h	2001-01-27 01:03:03.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-oid.h	2005-07-30 19:25:52.747323088 +0000
+@@ -108,7 +108,7 @@
+ 
+   PDU_MEMBER_MACROS
+ 
+-  void				Print (ostream &os) const;
++  void				Print (std::ostream &os) const;
+ 
+ #if META
+   static const AsnOidTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-real.h snacc-1.3bbn/c++-lib/inc/asn-real.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-real.h	2001-01-27 01:03:03.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-real.h	2005-07-30 19:26:05.321411536 +0000
+@@ -67,7 +67,7 @@
+   AsnLen			BEnc (BUF_TYPE b);
+   void				BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
+ 
+-  void				Print (ostream &os) const;
++  void				Print (std::ostream &os) const;
+ 
+   PDU_MEMBER_MACROS
+ 
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/asn-type.h snacc-1.3bbn/c++-lib/inc/asn-type.h
+--- snacc-1.3bbn.orig/c++-lib/inc/asn-type.h	2001-01-27 01:03:03.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/asn-type.h	2005-07-30 19:26:16.551704272 +0000
+@@ -111,7 +111,7 @@
+ 
+ #endif
+ 
+-  virtual void			Print (ostream &) const;
++  virtual void			Print (std::ostream &) const;
+ 
+ #if META
+   static const AsnTypeDesc	_desc;
+diff -uraN snacc-1.3bbn.orig/c++-lib/inc/print.h snacc-1.3bbn/c++-lib/inc/print.h
+--- snacc-1.3bbn.orig/c++-lib/inc/print.h	2001-01-27 01:03:03.000000000 +0000
++++ snacc-1.3bbn/c++-lib/inc/print.h	2005-07-30 19:26:54.240974632 +0000
+@@ -42,8 +42,8 @@
+ extern unsigned short int	indentG;
+ extern unsigned short int	stdIndentG;
+ 
+-void				Indent (ostream &os, unsigned short int i);
++void				Indent (std::ostream &os, unsigned short int i);
+ 
+-ostream				&operator << (ostream &os, const AsnType &a);
++std::ostream			&operator << (std::ostream &os, const AsnType &a);
+ 
+ #endif /* conditional include */
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-any.C snacc-1.3bbn/c++-lib/src/asn-any.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-any.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-any.C	2005-07-30 19:27:15.597727912 +0000
+@@ -165,7 +165,7 @@
+ }
+ 
+ 
+-void AsnAny::Print (ostream &os) const
++void AsnAny::Print (std::ostream &os) const
+ {
+   os << value;
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-bits.C snacc-1.3bbn/c++-lib/src/asn-bits.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-bits.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-bits.C	2005-07-30 19:27:51.063336320 +0000
+@@ -65,6 +65,8 @@
+ #include "asn-bits.h"
+ #include "str-stk.h"
+ 
++using std::endl;
++
+ extern StrStk strStkG;
+ unsigned short int  strStkUnusedBitsG;
+ 
+@@ -440,7 +442,7 @@
+ }  /* BDecConsBits */
+ 
+ // prints the BIT STRING to the given ostream.
+-void AsnBits::Print (ostream &os) const
++void AsnBits::Print (std::ostream &os) const
+ {
+     size_t octetLen = (bitLen+7)/8;
+ 
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-bool.C snacc-1.3bbn/c++-lib/src/asn-bool.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-bool.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-bool.C	2005-07-30 19:28:23.793360600 +0000
+@@ -54,6 +54,8 @@
+ #include "asn-type.h"
+ #include "asn-bool.h"
+ 
++using std::endl;
++
+ AsnType *AsnBool::Clone() const
+ {
+   return new AsnBool;
+@@ -110,7 +112,7 @@
+ }
+ 
+ // print the BOOLEAN's value in ASN.1 value notation to the given ostream
+-void AsnBool::Print (ostream &os) const
++void AsnBool::Print (std::ostream &os) const
+ {
+   os << (value ? "TRUE" : "FALSE");
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-enum.C snacc-1.3bbn/c++-lib/src/asn-enum.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-enum.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-enum.C	2005-07-30 19:28:57.068302040 +0000
+@@ -41,9 +41,11 @@
+ #include "asn-int.h"
+ #include "asn-enum.h"
+ 
++using std::endl;
++
+ AsnType *AsnEnum::Clone() const
+ {
+-  cerr << "AsnEnum::Clone() called" << endl;
++  std::cerr << "AsnEnum::Clone() called" << endl;
+   abort();
+   return NULL;
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-int.C snacc-1.3bbn/c++-lib/src/asn-int.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-int.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-int.C	2005-07-30 19:31:10.276100376 +0000
+@@ -55,6 +55,8 @@
+ #include "asn-type.h"
+ #include "asn-int.h"
+ 
++using std::endl;
++
+ AsnType *AsnInt::Clone() const
+ {
+   return new AsnInt;
+@@ -171,7 +173,7 @@
+     BDecContent (b, MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE), elmtLen, bytesDecoded, env);
+ }
+ 
+-void AsnInt::Print (ostream &os) const
++void AsnInt::Print (std::ostream &os) const
+ {
+     os << value;
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-len.C snacc-1.3bbn/c++-lib/src/asn-len.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-len.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-len.C	2005-07-30 19:31:35.984192152 +0000
+@@ -41,6 +41,7 @@
+ #include "asn-config.h"
+ #include "asn-len.h"
+ 
++using std::endl;
+ 
+ /*
+  * Encodes the given length to the given buffer.
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-list.C snacc-1.3bbn/c++-lib/src/asn-list.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-list.C	2001-01-27 01:03:00.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-list.C	2005-07-30 19:32:25.815616624 +0000
+@@ -62,6 +62,8 @@
+ #include "asn-tag.h"
+ #include "asn-type.h"
+ 
++using std::endl;
++
+ #ifdef __GNUG__
+ #pragma implementation
+ #endif
+@@ -80,7 +82,7 @@
+ 
+ // print routine for lists
+ template <class T>
+-ostream &operator << (ostream &os, AsnList<T> &l)
++std::ostream &operator << (std::ostream &os, AsnList<T> &l)
+ {
+     os << "SEQUENCE OF { ";
+ 
+@@ -241,7 +243,7 @@
+      {
+          listElmtTagId = BDecTag (b, bytesDecoded, env);
+ 
+-         if ((listElmtTagId == EOC) && (elmtLen == INDEFINITE_LEN))
++         if ((listElmtTagId == EOC_TAG_ID) && (elmtLen == INDEFINITE_LEN))
+              break;
+ 
+ 
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-null.C snacc-1.3bbn/c++-lib/src/asn-null.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-null.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-null.C	2005-07-30 19:33:01.169242056 +0000
+@@ -48,6 +48,8 @@
+ #include "asn-type.h"
+ #include "asn-null.h"
+ 
++using std::endl;
++
+ AsnType *AsnNull::Clone() const
+ {
+   return new AsnNull;
+@@ -85,7 +87,7 @@
+     BDecContent (b, MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE), elmtLen, bytesDecoded, env);
+ }
+ 
+-void AsnNull::Print (ostream &os) const
++void AsnNull::Print (std::ostream &os) const
+ {
+     os << "NULL";
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-octs.C snacc-1.3bbn/c++-lib/src/asn-octs.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-octs.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-octs.C	2005-07-30 19:33:30.540776904 +0000
+@@ -58,6 +58,8 @@
+ #include "asn-octs.h"
+ #include "str-stk.h"
+ 
++using std::endl;
++
+ extern StrStk strStkG;
+ 
+ AsnOcts::~AsnOcts()
+@@ -166,7 +168,7 @@
+ 
+ 
+ // Prints the AsnOcts to the given ostream in Value Notation.
+-void AsnOcts::Print (ostream &os) const
++void AsnOcts::Print (std::ostream &os) const
+ {
+     int i;
+     os << "'";
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-oid.C snacc-1.3bbn/c++-lib/src/asn-oid.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-oid.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-oid.C	2005-07-30 19:43:47.320214040 +0000
+@@ -51,7 +51,7 @@
+ 
+ #include "asn-config.h"
+ #if TCL
+-#include <strstream.h>
++#include <strstream>
+ #endif
+ #include "asn-len.h"
+ #include "asn-tag.h"
+@@ -59,6 +59,8 @@
+ #include "asn-oid.h"
+ #include "print.h"
+ 
++using std::endl;
++
+ AsnOid::~AsnOid()
+ {
+   delete oid;
+@@ -157,7 +159,7 @@
+     *(tmpBuf++) = 0x7f & headArcNum;
+ 
+     // repeat for the rest of the arc numbers
+-    for (i = 2; (i < 11) && (arcNumArr[i] > 0); i++)
++    for (int i = 2; (i < 11) && (arcNumArr[i] > 0); i++)
+     {
+         tmpArcNum = arcNumArr[i];
+         for (elmtLen = 1; (tmpArcNum >>= 7) != 0; elmtLen++)
+@@ -308,7 +310,7 @@
+ 
+ // Prints an AsnOid in ASN.1 Value Notation.
+ // Decodes the oid to get the individual arc numbers
+-void AsnOid::Print (ostream &os) const
++void AsnOid::Print (std::ostream &os) const
+ {
+   unsigned short int firstArcNum;
+   unsigned long int arcNum;
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-real.C snacc-1.3bbn/c++-lib/src/asn-real.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-real.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-real.C	2005-07-30 19:44:57.954476000 +0000
+@@ -57,12 +57,16 @@
+ #include "asn-type.h"
+ #include "asn-real.h"
+ 
++using std::endl;
++
+ #ifndef IEEE_REAL_LIB
+ /* ieee functions (in case not in math.h)*/
+ extern "C" {
+ extern int iszero (double);
++#if defined(__GNUC__) && (__GNUC__ < 3)
+ extern int isinf (double);
+ extern int signbit (double);
++#endif /* __GNUC__ && __GNUC__ < 3 */
+ extern int ilogb (double);
+ extern double scalbn (double, int);
+ }
+@@ -841,7 +845,7 @@
+     BDecContent (b, MAKE_TAG_ID (UNIV, PRIM, REAL_TAG_CODE), elmtLen, bytesDecoded, env);
+ }
+ 
+-void AsnReal::Print (ostream &os) const
++void AsnReal::Print (std::ostream &os) const
+ {
+   os << value;
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-tag.C snacc-1.3bbn/c++-lib/src/asn-tag.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-tag.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-tag.C	2005-07-30 19:45:24.267135808 +0000
+@@ -45,6 +45,8 @@
+ #include "asn-len.h"
+ #include "asn-tag.h"
+ 
++using std::endl;
++
+ /*
+  * Decode a BER Tag from the given buffer.  Error is
+  * flagged if the tag is too long or if a read error occurs.
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/asn-type.C snacc-1.3bbn/c++-lib/src/asn-type.C
+--- snacc-1.3bbn.orig/c++-lib/src/asn-type.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/asn-type.C	2005-07-30 19:30:07.294675008 +0000
+@@ -72,6 +72,8 @@
+ #include "asn-len.h"
+ #include "asn-type.h"
+ 
++using std::endl;
++
+ AsnType::~AsnType()
+ {
+ }
+@@ -97,7 +99,7 @@
+ 
+ #endif
+ 
+-void AsnType::Print (ostream &os) const
++void AsnType::Print (std::ostream &os) const
+ {
+   os << "ERROR - Attempt to print an improperly formed ANY type (programming error)." << endl;
+ }
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/meta.C snacc-1.3bbn/c++-lib/src/meta.C
+--- snacc-1.3bbn.orig/c++-lib/src/meta.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/meta.C	2005-07-30 19:46:03.588158104 +0000
+@@ -27,6 +27,8 @@
+ 
+ #include "asn-incl.h"
+ 
++using std::endl;
++
+ #if META
+ 
+ AsnMemberDesc::AsnMemberDesc (const char *_name, const AsnTypeDesc *_desc):
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/print.C snacc-1.3bbn/c++-lib/src/print.C
+--- snacc-1.3bbn.orig/c++-lib/src/print.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/print.C	2005-07-30 19:46:33.326637168 +0000
+@@ -45,13 +45,13 @@
+ unsigned short int stdIndentG = 4;
+ 
+ void
+-Indent (ostream &os, unsigned short int i)
++Indent (std::ostream &os, unsigned short int i)
+ {
+   while (i-->0)
+     os <<  ' ';
+ }
+ 
+-ostream &operator << (ostream &os, const AsnType &v)
++std::ostream &operator << (std::ostream &os, const AsnType &v)
+ {
+   v.Print (os);
+   return os;
+diff -uraN snacc-1.3bbn.orig/c++-lib/src/tcl-if.C snacc-1.3bbn/c++-lib/src/tcl-if.C
+--- snacc-1.3bbn.orig/c++-lib/src/tcl-if.C	2001-01-27 01:03:01.000000000 +0000
++++ snacc-1.3bbn/c++-lib/src/tcl-if.C	2005-07-30 19:48:01.296263752 +0000
+@@ -28,12 +28,13 @@
+ #include <assert.h>
+ #include <unistd.h>
+ #include <stdlib.h>
+-#include <strstream.h>
+-#include <fstream.h>
++#include <sstream>
+ #include <string.h>
+ 
+ #include "asn-incl.h"
+ 
++using std::endl;
++
+ #if TCL
+ 
+ #ifdef _AIX32
+@@ -835,7 +836,7 @@
+     }
+ 
+ cout << *var;
+-  strstream s;
++  stringstream s;
+   s << *var;
+   s.put ('\0');
+   cout << strlen(s.str()) << endl;
+diff -uraN snacc-1.3bbn.orig/compiler/back-ends/c++-gen/gen-code.c snacc-1.3bbn/compiler/back-ends/c++-gen/gen-code.c
+--- snacc-1.3bbn.orig/compiler/back-ends/c++-gen/gen-code.c	2001-01-27 01:02:54.000000000 +0000
++++ snacc-1.3bbn/compiler/back-ends/c++-gen/gen-code.c	2005-07-30 19:58:00.407885728 +0000
+@@ -453,7 +453,7 @@
+         fprintf (src, "    else\n");
+         fprintf (src, "        return false;\n");
+ /*
+-        fprintf (src, "    { cerr << \"longjmp return value is \" << val << endl;\n");
++        fprintf (src, "    { std::cerr << \"longjmp return value is \" << val << std::endl;\n");
+         fprintf (src, "        return false; }\n");
+ */
+         fprintf (src, "}\n\n");
+@@ -999,7 +999,7 @@
+                                 fprintf (src, ")\n");
+                         }
+                         fprintf (src, "    {\n");
+-            		fprintf (src, "        Asn1Error << \"%s::B%s: ERROR - wrong tag\" << endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
++            		fprintf (src, "        Asn1Error << \"%s::B%s: ERROR - wrong tag\" << std::endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
+                         fprintf (src, "        longjmp (env, %d);\n", longJmpValG--);
+                         fprintf (src, "    }\n");
+ 
+@@ -1357,7 +1357,7 @@
+ 
+     fprintf (src, "%s::%s (const %s &)\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "{\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "}\n\n");
+ 
+@@ -1423,7 +1423,7 @@
+     fprintf (src, "\n");
+     fprintf (src, "  return *this;\n");
+     fprintf (src, "#else // SNACC_DEEP_COPY\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "  // if your compiler complains here, check the -novolat option\n");
+     if (novolatilefuncs)
+@@ -1666,7 +1666,7 @@
+                         }
+ 
+                         fprintf (src, "      {\n");
+-                        fprintf (src, "         Asn1Error << \"Unexpected Tag\" << endl;\n");
++                        fprintf (src, "         Asn1Error << \"Unexpected Tag\" << std::endl;\n");
+                         fprintf (src, "         longjmp (env, %d);\n", longJmpValG--);
+                         fprintf (src, "      }\n\n");
+ 
+@@ -1780,7 +1780,7 @@
+         }
+ 
+         fprintf (src, "    default:\n");
+-        fprintf (src, "      Asn1Error << \"ERROR - unexpected tag in CHOICE\" << endl;\n");
++        fprintf (src, "      Asn1Error << \"ERROR - unexpected tag in CHOICE\" << std::endl;\n");
+         fprintf (src, "      longjmp (env, %d);\n", longJmpValG--);
+         fprintf (src, "      break;\n");
+ 
+@@ -1847,7 +1847,7 @@
+             else
+                 fprintf (src, "MAKE_TAG_ID (%s, %s, %d))", classStr, formStr, tag->code);
+             fprintf (src, "    {\n");
+-	    fprintf (src, "        Asn1Error << \"%s::B%s: ERROR - wrong tag\" << endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
++	    fprintf (src, "        Asn1Error << \"%s::B%s: ERROR - wrong tag\" << std::endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
+             fprintf (src, "        longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "    }\n");
+             fprintf (src, "    extraLen%d = BDecLen (b, bytesDecoded, env);\n", ++elmtLevel);
+@@ -1876,11 +1876,11 @@
+     /* ostream printing routine */
+     if (printPrintersG)
+     {
+-        fprintf (hdr, "  void			Print (ostream &os) const;\n", td->cxxTypeDefInfo->className);
++        fprintf (hdr, "  void			Print (std::ostream &os) const;\n", td->cxxTypeDefInfo->className);
+ 
+-        fprintf (src, "void %s::Print (ostream &os) const\n", td->cxxTypeDefInfo->className);
++        fprintf (src, "void %s::Print (std::ostream &os) const\n", td->cxxTypeDefInfo->className);
+         fprintf (src, "{\n");
+-        /*    fprintf (src, "  os << \"{\" << endl;\n") */
++        /*    fprintf (src, "  os << \"{\" << std::endl;\n") */
+         fprintf (src, "  switch (choiceId)\n");
+         fprintf (src, "  {\n");
+         FOR_EACH_LIST_ELMT (e, choice->basicType->a.choice)
+@@ -1909,7 +1909,7 @@
+         }
+         fprintf (src, "  } // end of switch\n");
+ 
+-        /*    fprintf (src, "  os << \"}\" << endl;\n") */
++        /*    fprintf (src, "  os << \"}\" << std::endl;\n") */
+         fprintf (src, "} // %s::Print\n\n", td->cxxTypeDefInfo->className);
+     }
+     /* end of Print Method code */
+@@ -2260,7 +2260,7 @@
+ 
+     fprintf (src, "%s::%s (const %s &)\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "{\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "}\n\n");
+ 
+@@ -2310,7 +2310,7 @@
+     fprintf (src, "\n");
+     fprintf (src, "  return *this;\n");
+     fprintf (src, "#else // SNACC_DEEP_COPY\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "  // if your compiler complains here, check the -novolat option\n");
+     if (novolatilefuncs)
+@@ -2460,7 +2460,7 @@
+             fprintf (src, "    BDecEoc (b, bytesDecoded, env);\n");
+             fprintf (src, "  else if (elmtLen0 != 0)\n");
+             fprintf (src, "  {\n");
+-            fprintf (src, "     Asn1Error << \"Expected an empty sequence\" << endl;\n");
++            fprintf (src, "     Asn1Error << \"Expected an empty sequence\" << std::endl;\n");
+             fprintf (src, "     longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -2638,7 +2638,7 @@
+                             }
+ 
+                             fprintf (src, "    {\n");
+-                            fprintf (src, "       Asn1Error << \"Unexpected Tag\" << endl;\n");
++                            fprintf (src, "       Asn1Error << \"Unexpected Tag\" << std::endl;\n");
+                             fprintf (src, "       longjmp (env, %d);\n", longJmpValG--);
+                             fprintf (src, "    }\n\n");
+                             fprintf (src, "    elmtLen%d = BDecLen (b, seqBytesDecoded, env);\n", ++elmtLevel);
+@@ -2826,7 +2826,7 @@
+                     fprintf (src, "  }\n"); /* end of tag check if */
+                     fprintf (src, "  else\n");
+                     fprintf (src, "  {\n");
+-                    fprintf (src, "    Asn1Error << \"ERROR - SEQUENCE is missing non-optional elmt.\" << endl;\n");
++                    fprintf (src, "    Asn1Error << \"ERROR - SEQUENCE is missing non-optional elmt.\" << std::endl;\n");
+                     fprintf (src, "    longjmp (env, %d);\n", longJmpValG--);
+                     fprintf (src, "  }\n\n");
+                 }
+@@ -2845,7 +2845,7 @@
+             fprintf (src, "  }\n");
+             fprintf (src, "  else if (seqBytesDecoded != elmtLen0)\n");
+             fprintf (src, "  {\n");
+-            fprintf (src, "    Asn1Error << \"ERROR - Length discrepancy on sequence.\" << endl;\n");
++            fprintf (src, "    Asn1Error << \"ERROR - Length discrepancy on sequence.\" << std::endl;\n");
+             fprintf (src, "    longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+             fprintf (src, "  else\n");
+@@ -2914,7 +2914,7 @@
+             else
+                 fprintf (src, "MAKE_TAG_ID (%s, %s, %d))\n", classStr, formStr, tag->code);
+             fprintf (src, "  {\n");
+-	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
++	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << std::endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
+             fprintf (src, "    longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -2939,14 +2939,14 @@
+     /* write code for printing */
+     if (printPrintersG)
+     {
+-        fprintf (hdr, "  void		Print (ostream &os) const;\n");
++        fprintf (hdr, "  void		Print (std::ostream &os) const;\n");
+ 
+-        fprintf (src, "void %s::Print (ostream &os) const\n", td->cxxTypeDefInfo->className);
++        fprintf (src, "void %s::Print (std::ostream &os) const\n", td->cxxTypeDefInfo->className);
+         fprintf (src, "{\n");
+         allOpt = AllElmtsOptional (seq->basicType->a.sequence);
+         if (allOpt)
+             fprintf (src, "  int nonePrinted = true;\n");
+-        fprintf (src, "  os << \"{ -- SEQUENCE --\" << endl;\n");
++        fprintf (src, "  os << \"{ -- SEQUENCE --\" << std::endl;\n");
+         fprintf (src, "  indentG += stdIndentG;\n\n");
+ 
+         FOR_EACH_LIST_ELMT (e, seq->basicType->a.sequence)
+@@ -2963,12 +2963,12 @@
+                 if (e != FIRST_LIST_ELMT (seq->basicType->a.sequence))
+                 {
+                     fprintf (src, "    if (!nonePrinted)\n");
+-                    fprintf (src, "      os << \",\" << endl;\n");
++                    fprintf (src, "      os << \",\" << std::endl;\n");
+                 }
+                 fprintf (src, "    nonePrinted = false;\n", i);
+             }
+             else if (inTailOptElmts) /* cannot be first elmt ow allOpt is true */
+-                fprintf (src, "    os << \",\"<< endl;\n");
++                fprintf (src, "    os << \",\"<< std::endl;\n");
+ 
+             fprintf (src, "    Indent (os, indentG);\n");
+ 
+@@ -2982,10 +2982,10 @@
+ 
+ #ifdef KHO
+             if (e != LAST_LIST_ELMT (seq->basicType->a.sequence)&&(!e->type->cxxTypeRefInfo->isPtr) )
+-                fprintf (src, "    os << \",\" << endl;\n");
++                fprintf (src, "    os << \",\" << std::endl;\n");
+ #else
+             if (e != LAST_LIST_ELMT (seq->basicType->a.sequence) && !inTailOptElmts && !NextIsTailOptional (seq->basicType->a.sequence))
+-                fprintf (src, "    os << \",\" << endl;\n");
++                fprintf (src, "    os << \",\" << std::endl;\n");
+ #endif
+ 
+ 	    fprintf (src, "  }\n");
+@@ -3000,9 +3000,9 @@
+                   fprintf (src, "    os << \"%s \";\n", e->fieldName);
+ 		fprintf (src, "    os << \"-- void --\";\n");
+     		if (e != LAST_LIST_ELMT (seq->basicType->a.sequence))
+-                   fprintf (src, "    os << \",\" << endl;\n");
++                   fprintf (src, "    os << \",\" << std::endl;\n");
+                 else
+-                   fprintf (src, "    os << endl;\n");
++                   fprintf (src, "    os << std::endl;\n");
+ 		fprintf (src, "  }\n");
+ #else
+ 		fprintf (src, "    os << \"-- void --\";\n");
+@@ -3012,7 +3012,7 @@
+ 	    fprintf (src, "\n");
+ 
+             if (e == LAST_LIST_ELMT (seq->basicType->a.sequence))
+-                fprintf (src, "  os << endl;\n");
++                fprintf (src, "  os << std::endl;\n");
+         }
+ 
+         fprintf (src, "  indentG -= stdIndentG;\n");
+@@ -3361,7 +3361,7 @@
+ 
+     fprintf (src, "%s::%s (const %s &)\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "{\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "}\n\n");
+ 
+@@ -3411,7 +3411,7 @@
+     fprintf (src, "\n");
+     fprintf (src, "  return *this;\n");
+     fprintf (src, "#else // SNACC_DEEP_COPY\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "  // if your compiler complains here, check the -novolat option\n");
+     if (novolatilefuncs)
+@@ -3557,7 +3557,7 @@
+             fprintf (src, "    BDecEoc (b, bytesDecoded, env);\n");
+             fprintf (src, "  else if (elmtLen0 != 0)\n");
+             fprintf (src, "  {\n");
+-            fprintf (src, "     Asn1Error << \"Expected an empty sequence\" << endl;\n");
++            fprintf (src, "     Asn1Error << \"Expected an empty sequence\" << std::endl;\n");
+             fprintf (src, "     longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -3697,7 +3697,7 @@
+                             }
+ 
+                             fprintf (src, "        {\n");
+-                            fprintf (src, "           Asn1Error << \"Unexpected Tag\" << endl;\n");
++                            fprintf (src, "           Asn1Error << \"Unexpected Tag\" << std::endl;\n");
+                             fprintf (src, "           longjmp (env, %d);\n", longJmpValG--);
+                             fprintf (src, "        }\n\n");
+ 
+@@ -3814,14 +3814,14 @@
+                 FreeTags (tags);
+             } /* for each elmt */
+             fprintf (src, "       default:\n");
+-            fprintf (src, "         Asn1Error << \"Unexpected Tag on SET elmt.\" << endl;\n");
++            fprintf (src, "         Asn1Error << \"Unexpected Tag on SET elmt.\" << std::endl;\n");
+             fprintf (src, "         longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "    } // end switch\n");
+             fprintf (src, "  } // end for loop\n");
+             fprintf (src, "  bytesDecoded += setBytesDecoded;\n");
+             fprintf (src, "  if (mandatoryElmtsDecoded != %d)\n", mandatoryElmtCount);
+             fprintf (src, "  {\n");
+-            fprintf (src, "     Asn1Error << \"ERROR - non-optional SET element missing.\" << endl;\n");
++            fprintf (src, "     Asn1Error << \"ERROR - non-optional SET element missing.\" << std::endl;\n");
+             fprintf (src, "     longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -3889,7 +3889,7 @@
+             else
+                 fprintf (src, "MAKE_TAG_ID (%s, %s, %d))\n", classStr, formStr, tag->code);
+             fprintf (src, "  {\n");
+-	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
++	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << std::endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
+             fprintf (src, "    longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -3914,15 +3914,15 @@
+     /* write code for printing */
+     if (printPrintersG)
+     {
+-        fprintf (hdr, "  void			Print (ostream &os) const;\n");
++        fprintf (hdr, "  void			Print (std::ostream &os) const;\n");
+ 
+-        fprintf (src, "void %s::Print (ostream &os) const\n", td->cxxTypeDefInfo->className);
++        fprintf (src, "void %s::Print (std::ostream &os) const\n", td->cxxTypeDefInfo->className);
+         fprintf (src, "{\n");
+         allOpt = AllElmtsOptional (set->basicType->a.set);
+         if (allOpt)
+             fprintf (src, "  int nonePrinted = true;\n");
+ 
+-        fprintf (src, "  os << \"{ -- SET --\" << endl;\n");
++        fprintf (src, "  os << \"{ -- SET --\" << std::endl;\n");
+         fprintf (src, "  indentG += stdIndentG;\n\n");
+ 
+         FOR_EACH_LIST_ELMT (e, set->basicType->a.set)
+@@ -3939,12 +3939,12 @@
+                 if (e != FIRST_LIST_ELMT (set->basicType->a.set))
+                 {
+                     fprintf (src, "    if (!nonePrinted)\n");
+-                    fprintf (src, "      os << \",\" << endl;\n");
++                    fprintf (src, "      os << \",\" << std::endl;\n");
+                 }
+                 fprintf (src, "    nonePrinted = false;\n", i);
+             }
+             else if (inTailOptElmts) /* cannot be first elmt ow allOpt is true */
+-                fprintf (src, "    os << \",\"<< endl;\n");
++                fprintf (src, "    os << \",\"<< std::endl;\n");
+ 
+             fprintf (src, "    Indent (os, indentG);\n");
+ 
+@@ -3957,7 +3957,7 @@
+                 fprintf (src, "    os << %s;\n", e->type->cxxTypeRefInfo->fieldName);
+ 
+             if (e != LAST_LIST_ELMT (set->basicType->a.set) && !inTailOptElmts && !NextIsTailOptional (set->basicType->a.set))
+-                fprintf (src, "    os << \",\" << endl;\n");
++                fprintf (src, "    os << \",\" << std::endl;\n");
+ 
+ 	    fprintf (src, "  }\n");
+ 
+@@ -3974,7 +3974,7 @@
+ 	    fprintf (src, "\n");
+ 
+             if (e == LAST_LIST_ELMT (set->basicType->a.set))
+-                fprintf (src, "  os << endl;\n");
++                fprintf (src, "  os << std::endl;\n");
+         }
+         fprintf (src, "  indentG -= stdIndentG;\n");
+         fprintf (src, "  Indent (os, indentG);\n");
+@@ -4294,7 +4294,7 @@
+             else
+                 fprintf (src, "MAKE_TAG_ID (%s, %s, %d))\n", classStr, formStr, tag->code);
+             fprintf (src, "  {\n");
+-	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
++	    fprintf (src, "    Asn1Error << \"%s::B%s: ERROR - wrong tag\" << std::endl;\n", td->cxxTypeDefInfo->className, r->decodeBaseName);
+             fprintf (src, "    longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "  }\n");
+ 
+@@ -4324,7 +4324,7 @@
+     fprintf (hdr, "  PDU_MEMBER_MACROS\n");
+ 
+     if (printPrintersG)
+-        fprintf (hdr, "  void		Print (ostream &os) const;\n");
++        fprintf (hdr, "  void		Print (std::ostream &os) const;\n");
+ 
+     fprintf (hdr, "};\n\n\n");
+ 
+@@ -4380,7 +4380,7 @@
+         }
+         fprintf (src, "))\n");
+         fprintf (src, "        {\n");
+-        fprintf (src, "            Asn1Error << \"Unexpected Tag\" << endl;\n");
++        fprintf (src, "            Asn1Error << \"Unexpected Tag\" << std::endl;\n");
+         fprintf (src, "            longjmp (env, %d);\n", longJmpValG--);
+         fprintf (src, "        }\n\n");
+         fprintf (src, "        elmtLen%d = BDecLen (b, listBytesDecoded, env);\n", ++elmtLevel);
+@@ -4406,7 +4406,7 @@
+                 fprintf (src, "))\n");
+ 
+             fprintf (src, "        {\n");
+-            fprintf (src, "            Asn1Error << \"Unexpected Tag\" << endl;\n");
++            fprintf (src, "            Asn1Error << \"Unexpected Tag\" << std::endl;\n");
+             fprintf (src, "            longjmp (env, %d);\n", longJmpValG--);
+             fprintf (src, "        }\n\n");
+             fprintf (src, "        elmtLen%d = BDecLen (b, listBytesDecoded, env);\n", ++elmtLevel);
+@@ -4461,7 +4461,7 @@
+ 
+     fprintf (src, "%s::%s (const %s &)\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "{\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s::%s (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "}\n\n");
+ 
+@@ -4494,7 +4494,7 @@
+     fprintf (src, "\n");
+     fprintf (src, "  return *this;\n");
+     fprintf (src, "#else // SNACC_DEEP_COPY\n");
+-    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
++    fprintf (src, "  Asn1Error << \"use of incompletely defined %s &%s::operator = (const %s &)\" << std::endl;\n", td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className, td->cxxTypeDefInfo->className);
+     fprintf (src, "  abort();\n");
+     fprintf (src, "  // if your compiler complains here, check the -novolat option\n");
+     if (novolatilefuncs)
+@@ -4506,9 +4506,9 @@
+ 
+     if (printPrintersG)
+     {
+-        fprintf (src, "void %s::Print (ostream &os) const\n", td->cxxTypeDefInfo->className);
++        fprintf (src, "void %s::Print (std::ostream &os) const\n", td->cxxTypeDefInfo->className);
+         fprintf (src, "{\n");
+-        fprintf (src, "    os << \"{ -- SEQUENCE/SET OF -- \" << endl;\n");
++        fprintf (src, "    os << \"{ -- SEQUENCE/SET OF -- \" << std::endl;\n");
+         fprintf (src, "    indentG += stdIndentG;\n");
+ 
+         fprintf (src, "    //SetCurrToFirst();\n");
+@@ -4521,7 +4521,7 @@
+         fprintf (src, "        //if (Curr() != Last())\n");
+         fprintf (src, "        if (run != last)\n");
+         fprintf (src, "            os << \",\";\n");
+-        fprintf (src, "        os << endl;\n");
++        fprintf (src, "        os << std::endl;\n");
+         fprintf (src, "    }\n");
+ 
+         fprintf (src, "    indentG -= stdIndentG;\n");
+diff -uraN snacc-1.3bbn.orig/compiler/back-ends/c-gen/gen-code.c snacc-1.3bbn/compiler/back-ends/c-gen/gen-code.c
+--- snacc-1.3bbn.orig/compiler/back-ends/c-gen/gen-code.c	2001-01-27 01:02:52.000000000 +0000
++++ snacc-1.3bbn/compiler/back-ends/c-gen/gen-code.c	2005-07-30 19:22:04.488877784 +0000
+@@ -33,6 +33,7 @@
+  */
+ 
+ #include <stdio.h>
++#include <time.h>
+ 
+ #include "asn-incl.h"
+ #include "asn1module.h"
+diff -uraN snacc-1.3bbn.orig/compiler/core/parse-asn1.y snacc-1.3bbn/compiler/core/parse-asn1.y
+--- snacc-1.3bbn.orig/compiler/core/parse-asn1.y	2001-01-27 01:02:47.000000000 +0000
++++ snacc-1.3bbn/compiler/core/parse-asn1.y	2005-07-30 17:29:02.838828848 +0000
+@@ -456,6 +456,7 @@
+ /*-----------------------------------------------------------------------*/
+ 
+ LineNo: { $$ = myLineNoG; }
++;
+ 
+ ModuleDefinition:
+      ModuleIdentifier
+@@ -1462,6 +1463,7 @@
+         $$->choiceId = SUBTYPEVALUE_SINGLEVALUE;
+         $$->a.singleValue = $1;
+     }
++;
+ 
+ ContainedSubtype:
+     INCLUDES_SYM Type
--- snacc-1.3bbn.orig/debian/patches/examples.patch
+++ snacc-1.3bbn/debian/patches/examples.patch
@@ -0,0 +1,5429 @@
+diff -uraN snacc-1.3bbn/c++-examples/any/README snacc-1.3b4/c++-examples/any/README
+--- snacc-1.3bbn/c++-examples/any/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/any/README	1997-02-16 20:25:26.000000000 +0000
+@@ -0,0 +1,90 @@
++(RCS control information is at the end of this file.)
++
++
++C++ ANY example README
++---------------------
++
++This example shows how the snacc compiler handles the ANY DEFINED BY
++type in C++.  ANY types (not ANY DEFINED BY) require modifications
++to the generated code.  Type "make" to build this example.
++
++This directory should have the following 4 files in it:
++
++        README
++        example.C
++        genber.C
++        makefile
++
++There are 3 programs generated by the makefile:
++
++        genber - builds a BER value of the AnyTestType and writes it
++                 to a file called "att.ber"
++
++        def    - takes file name of an AnyTestType BER value.  Decodes the
++                 file and re-encodes it to stdout.  Uses definite
++                 lengths for constructed values.
++
++        indef  - takes file name of an AnyTestType BER value.  Decodes the
++                 file and re-encodes it to stdout.  Uses indefinite
++                 lengths for constructed values.
++
++
++These files use the code generated by snacc from the
++snacc/asn1specs/any.asn1 file. (see the makefile)
++
++Look at genber.C to see how values can be built and printed.
++
++Look at the generated code in any_test.C and any_test.h to see how the
++any hash table is built.
++
++
++try the following commands in your c-shell:
++
++%1 genber                   # generate the att.ber file
++%2 indef att.ber > tmp.ber  # decode att.ber an re-encode into tmp.ber
++%3 def tmp.ber > tmp2.ber   # decode tmp.ber an re-encode into tmp2.ber
++%4 diff att.ber tmp2.ber    # compare .ber files (should be the same)
++
++When you are finished with the example type "make clean"  to remove
++the binaries and generated code.
++
++
++
++Things To Note
++--------------
++
++Snacc ASN.1 comment commands
++
++In the snacc/asn1specs/any.asn1 file, the AnyTestType has a special
++"--snacc" ASN.1 comment after ::= to give snacc some extra information
++about the AnyTestType.
++
++AnyTestType ::= --snacc isPdu:"TRUE" -- SEQUENCE { ... etc. ... }
++
++The "isPdu" flag only affects the generated C code, not C++.  Each
++C++ type gets PDU methods by default.
++
++
++SNMP OBJECT-TYPE Macro
++
++The SNMP OBJECT-TYPE macro is used to define the id value to type
++mapping for ANY DEFINED BY types.  The macro has been modified to
++accept both INTEGERs and OBJECT IDENTIFIERs as id values (see
++snacc/asn1specs/any.asn1).  This macro can be used with other
++protocols to define the id to type mapping.
++
++Two hash tables are used to hold the id to type mappings. One for
++INTEGER to type mappings and the other for OBJECT IDENTIFIER to type
++mappings.  The hash tables are automatically initialized in each
++module that has OBJECT-TYPE macros.  In C the hash table must be
++explicitly initialized.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1997/02/16 20:25:26  rj
++# check-in of a few cosmetic changes
++#
++# Revision 1.1  1994/08/31  08:47:59  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c++-examples/any/example.C snacc-1.3b4/c++-examples/any/example.C
+--- snacc-1.3bbn/c++-examples/any/example.C	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/any/example.C	1995-07-24 15:33:33.000000000 +0000
+@@ -0,0 +1,115 @@
++// c++_examples/any/example.C - an example of how to use C++ ASN.1-BER
++//              for ANY Types
++//
++// AUTHOR: Mike Sample
++// DATE:   92
++//
++// $Header$
++// $Log$
++// Revision 1.5  1995/07/24 15:33:33  rj
++// changed `_' to `-' in file names.
++//
++// any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
++//
++// check return value of new.
++//
++// Revision 1.4  1995/02/18  13:53:07  rj
++// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
++//
++// Revision 1.3  1994/10/08  01:26:21  rj
++// several \size_t'
++//
++// Revision 1.2  1994/08/31  08:56:29  rj
++// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++//
++
++#include <stddef.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <fstream.h>
++
++#include "asn-incl.h"
++#include "any.h"
++
++main (int argc, char *argv[])
++{
++    if (argc != 2)
++    {
++        cerr << "Usage: " << argv[0] << " <BER data file name>" << endl;
++        cerr << "   Decodes the given AnyTestType BER data file" << endl;
++        cerr << "   and re-encodes it to stdout" << endl;
++        exit (1);
++    }
++
++    ifstream dataFile;
++    // open the data file
++    dataFile.open (argv[1]);
++
++    if (!dataFile)
++    {
++        perror ("ifstream::open");
++        exit (1);
++    }
++
++    // get size of the data file file
++    dataFile.seekg (0, ios::end);
++    int dataSize = dataFile.tellg();
++    dataFile.seekg (0);
++
++    // read data from file into contiguous block for a buffer
++#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
++    char data[dataSize];
++#else
++    char *data = new char[dataSize];
++    if (!data)
++	return 1;
++#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
++    dataFile.read (data, dataSize);
++    dataFile.close();
++
++    //
++    // put the BER data read from the file
++    // into buffer format, ready for reading from the
++    // beginning
++    //
++    AsnBuf inputBuf;
++    inputBuf.InstallData ((char*)data, dataSize);
++
++    size_t decodedLen;
++    AnyTestType att;
++
++    if (!att.BDecPdu (inputBuf, decodedLen))
++    {
++        cerr << "ERROR - Decode routines failed, exiting..." << endl;
++        exit (1);
++    }
++
++    cerr  << "decodedValue AnyTestType ::= " << att << endl << endl;
++
++    //
++    // allocate a new buffer and set up for writing to
++    //
++    AsnBuf  outputBuf;
++#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
++    char outputData[dataSize + 512];
++#else
++    char *outputData = new char[dataSize + 512];
++    if (!outputData)
++	return 1;
++#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
++    outputBuf.Init (outputData, dataSize+512);
++    outputBuf.ResetInWriteRvsMode();
++
++    size_t encodedLen;
++    if (!att.BEncPdu (outputBuf, encodedLen))
++    {
++        cerr << "ERROR - Encode routines failed" << endl;
++    }
++
++    // write the BER value to cout
++    outputBuf.ResetInReadMode();
++    for ( ; encodedLen > 0; encodedLen--)
++        cout.put (outputBuf.GetByte());
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c++-examples/any/genber.C snacc-1.3b4/c++-examples/any/genber.C
+--- snacc-1.3bbn/c++-examples/any/genber.C	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/any/genber.C	1995-07-24 15:33:34.000000000 +0000
+@@ -0,0 +1,150 @@
++// c++_examples/any/genber.C - builds an AnyTestType value and writes BER form
++//            of the value to a file called "att.ber"
++//
++//  Shows how to build internal rep of lists and ANY values.
++//
++// MS 92
++//
++// $Header$
++// $Log$
++// Revision 1.5  1995/07/24 15:33:34  rj
++// changed `_' to `-' in file names.
++//
++// any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
++//
++// check return value of new.
++//
++// Revision 1.4  1995/02/18  13:54:03  rj
++// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
++//
++// Revision 1.3  1994/10/08  01:26:22  rj
++// several \size_t'
++//
++// Revision 1.2  1994/08/31  08:56:30  rj
++// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++//
++
++
++#include <stddef.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <fstream.h>
++
++#include "asn-incl.h"
++#include "any.h"
++
++
++main (int argc, char *argv[])
++{
++    ofstream outputFile;
++    AsnBuf outputBuf;
++    size_t encodedLen;
++    size_t dataSize = 1024;
++#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
++    char data[dataSize];
++#else
++    char *data = new char[dataSize];
++    if (!data)
++	return 1;
++#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
++    AnyTestType att;
++    TSeq1 ts1;
++    TSeq2 ts2;
++    AttrValue1 *atv1ptr;
++    AttrValue2 *atv2ptr;
++    AsnInt intVal;
++    AsnBool boolVal;
++    AsnOcts octsVal ("Hi Mom");
++    OctsId octsIdVal = octsVal;
++    AsnBits bitsVal;
++    BitsId bitsIdVal (9);
++    AsnReal realVal;
++
++    // READ THIS!!!
++    // you must be really careful when setting the
++    // "value" field and "id" fields in an
++    // ANY/ANY DEFINED BY type because "value" is a
++    // "AsnType*" and will accept any
++    // pointer value.  It will even encode
++    // the wrong value without complaining if you
++    // set "value" to the wrong object.
++
++    atv1ptr = att.intMap.Append();
++    atv1ptr->id = intId;
++    intVal = -99;
++    atv1ptr->anyDefBy.value = &intVal;
++
++    atv1ptr = att.intMap.Append();
++    atv1ptr->id = boolId;
++    boolVal = true;
++    atv1ptr->anyDefBy.value = &boolVal;
++
++    atv1ptr = att.intMap.Append();
++    atv1ptr->id = octsId;
++    atv1ptr->anyDefBy.value = &octsIdVal;
++
++    atv1ptr = att.intMap.Append();
++    atv1ptr->id = bitsId;
++    bitsIdVal.SetBit (0);
++    bitsIdVal.ClrBit (1);
++    bitsIdVal.SetBit (2);
++    bitsIdVal.ClrBit (3);
++    bitsIdVal.SetBit (4);
++    bitsIdVal.ClrBit (5);
++    bitsIdVal.SetBit (6);
++    bitsIdVal.ClrBit (7);
++    bitsIdVal.SetBit (8);
++    bitsIdVal.ClrBit (9);
++    atv1ptr->anyDefBy.value = &bitsIdVal;
++
++    atv1ptr = att.intMap.Append();
++    atv1ptr->id = realId;
++    realVal = 108.3838;
++    atv1ptr->anyDefBy.value = &realVal;
++
++    // now do TSeq2 with same vals but use OID as identifier
++    atv2ptr = att.oidMap.Append();
++    atv2ptr->id = intOid;
++    atv2ptr->anyDefBy.value = &intVal;
++
++    atv2ptr = att.oidMap.Append();
++    atv2ptr->id = boolOid;
++    atv2ptr->anyDefBy.value = &boolVal;
++
++    atv2ptr = att.oidMap.Append();
++    atv2ptr->id = octsOid;
++    atv2ptr->anyDefBy.value = &octsVal;
++
++    atv2ptr = att.oidMap.Append();
++    atv2ptr->id = bitsOid;
++    bitsVal = bitsIdVal; // copy bits
++    atv2ptr->anyDefBy.value = &bitsVal;
++
++    atv2ptr = att.oidMap.Append();
++    atv2ptr->id = realOid;
++    atv2ptr->anyDefBy.value = &realVal;
++
++    outputBuf.Init (data, dataSize);
++    outputBuf.ResetInWriteRvsMode();
++
++    if (!att.BEncPdu (outputBuf, encodedLen))
++        cout << "failed encoding AnyTestType value" << endl;
++
++    outputFile.open ("att.ber");
++    if (!outputFile)
++    {
++        perror ("ofstream::open");
++        exit (1);
++    }
++
++    outputBuf.ResetInReadMode();
++    for ( ; encodedLen > 0; encodedLen--)
++        outputFile.put (outputBuf.GetByte());
++
++
++    cout << "Wrote the following BER AnyTestType value to att.ber." << endl;
++    cout << "Test it with \"def\" and \"indef\"" << endl;
++    cout << att << endl;
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c++-examples/any/makefile snacc-1.3b4/c++-examples/any/makefile
+--- snacc-1.3bbn/c++-examples/any/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/any/makefile	1997-02-16 16:47:46.000000000 +0000
+@@ -0,0 +1,154 @@
++# c++-examples/any/makefile
++#
++# WARNING: this makefile isn't safe for parallel making!
++#
++# builds the C++ ANY example
++#
++# MS 92
++#
++# $Header$
++# $Log$
++# Revision 1.9  1997/02/16 16:47:46  rj
++# made return *this after calling abort()'' a compile time option.
++#
++# Revision 1.8  1995/07/24  15:29:07  rj
++# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
++# any-test.[hC] becomes any.[hC] due to to snacc's new file name generation scheme.
++#
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.7  1995/02/20  11:46:19  rj
++# build snacc if it doesn't exist.
++# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
++#
++# Revision 1.6  1995/02/13  14:58:12  rj
++# augment CPPFLAGS, not overwrite
++#
++# Revision 1.5  1994/10/08  04:35:42  rj
++# enhance portability by using standard make capabilities instead of utilies (basename, dirname) not found on every platform.
++#
++# for the dependencies, generate the snacc compiler if it doesn't exist.
++#
++# Revision 1.4  1994/09/01  02:26:53  rj
++# use CXX instead of CC to get another default linkage
++#
++# Revision 1.3  1994/08/31  21:38:34  rj
++# rebuild the executables when the c++-lib is newer.
++#
++# Revision 1.2  1994/08/31  10:31:47  rj
++# since .o files get moved, a few more dependencies are needed.
++#
++# Revision 1.1  1994/08/31  08:48:03  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SRC_DIR	= $(TOP)/asn1specs
++
++ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
++ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
++ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
++SNACCFLAGS	= -C $(SNACC_NOVOLAT) -u $(USEFUL_TYPES)
++
++CC		= $(CXX)
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR) $(LENFLAG)
++
++ASN1FILES	= $(ASN1_SRC_DIR)/any.asn1
++
++# generated by snacc from any.asn1:
++ASN1HFILES	= any.h
++ASN1CFILES	= any.C
++
++CFILES = \
++	genber.C	\
++	example.C
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)
++
++#-------------------------------------------------------------------------------
++
++all::		genber def indef
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++def-obj		\
++indef-obj:
++		mkdir $@
++
++def-obj/any.o	\
++def-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++indef-obj/any.o	\
++indef-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++genber:		def-obj/any.o genber.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ def-obj/any.o genber.o $(ASN1_C++_LIB) $(LIBS)
++
++def: 		def-obj/any.o def-obj/example.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ def-obj/any.o def-obj/example.o $(ASN1_C++_LIB) $(LIBS)
++
++indef:		indef-obj/any.o indef-obj/example.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ indef-obj/any.o indef-obj/example.o $(ASN1_C++_LIB) $(LIBS)
++
++genber	\
++def	\
++indef:		$(ASN1_C++_LIB)
++
++.PHONY:	check
++
++check::		genber def indef
++		$(RM) foo.ber bar.ber
++		./genber
++		./indef att.ber > foo.ber
++		./def foo.ber > bar.ber
++		@echo ''
++		@if cmp -s bar.ber att.ber; then\
++		  echo "+++ Passed simple encode/decode tests using any.asn1.";\
++		else\
++		  echo "--- Failed simple encode/decode tests using any.asn1.";\
++		fi
++		@echo ''
++		$(RM) foo.ber bar.ber
++
++clean::
++		$(RM) *.o *~ .emacs* core def indef genber att.ber $(ASN1HFILES) $(ASN1CFILES)
++		$(RM) -r def-obj indef-obj
++		$(RM) foo.ber bar.ber
++
++depend::	$(SNACC)
++
++include ../../maketail
++
++depend::
++		cp dependencies deps
++		for dir in def-obj indef-obj; do\
++		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
++		done
++		mv deps dependencies
+diff -uraN snacc-1.3bbn/c++-examples/makefile snacc-1.3b4/c++-examples/makefile
+--- snacc-1.3bbn/c++-examples/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/makefile	1995-07-24 15:25:37.000000000 +0000
+@@ -0,0 +1,34 @@
++# file: .../c++-examples/makefile
++
++SUBDIRS		= test-lib simple any snmp
++
++#-------------------------------------------------------------------------------
++
++.PHONY:	implicit_default
++implicit_default::
++		$(MAKE) subdirs
++
++subdirs::	$(SUBDIRS)
++$(SUBDIRS)::
++		cd $@ && $(MAKE) $(subtarget)
++
++# the following hack is needed for older make versions (gmake doesn't need it):
++init-depend::
++		@for dir in $(SUBDIRS); do\
++		  test -f $$dir/dependencies || touch $$dir/dependencies;\
++		done
++
++.DEFAULT::
++		$(MAKE) subdirs subtarget=$@
++
++distfiles::
++		echo makefile
++		for dir in $(SUBDIRS); do\
++		  subfiles=`cd $$dir && $(MAKE) -s $@`;\
++		  for file in $$subfiles; do\
++		    echo "$$dir/$$file";\
++		  done;\
++		done
++
++# dummy:
++install::
+diff -uraN snacc-1.3bbn/c++-examples/simple/README snacc-1.3b4/c++-examples/simple/README
+--- snacc-1.3bbn/c++-examples/simple/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/simple/README	1994-10-08 04:43:46.000000000 +0000
+@@ -0,0 +1,105 @@
++(RCS control information is at the end of this file.)
++
++
++C++ Simple Example README
++-------------------------
++
++This directory should have 6 files in it:
++
++  README      - this file
++
++  genber.C    - C++ source code for a program that creates and encodes
++                a PersonnelRecord value to a file.
++
++  example.C   - C++ source code for a program that decodes a given
++                PersonnelRecord value and re-encodes it to stdout.
++
++  makefile    - compiles the example programs
++
++  good_pr.ber - BER encoding of a Personnel Record (all definite lengths)
++
++
++
++Type "make" to generate the 3 example programs:
++        genber
++        def
++        indef
++
++
++
++snacc is called from the makefile on .../asn1specs/p_rec.asn1 to
++generate the following files:
++
++p_rec.h  - C++ classes for PersonnelRecord types.
++
++p_rec.C  - C++ source code for the PersonnelRecord encode, decode,
++           print, and free methods.
++
++These source files are then compiled with example.C to make the
++programs def and indef.  Each program takes 1 argument, the name of a
++file containing an BER encoded PersonnelRecord value.
++
++
++Try the following:
++
++%1 genber                       # create a file called pr.ber
++%2 indef good_pr.ber > indef_pr.ber
++%3 def indef_pr.ber > def_pr.ber
++%4 diff good_pr.ber def_pr.ber  # should be no differences
++
++(commands 2-4 can be made via the `check' phony target.)
++
++The above commands decode the BER value in "good_pr.ber" and
++indef_pr.ber respectively and then re-encode them to stdout.
++Both programs will decode any valid BER representation of a
++PersonnelRecord value but, the def program will re-encode the
++given data using only the definite length BER format and the
++indef program will re-encode the given data using only the
++indefinite length BER format.
++
++Compare the lengths of the def_pr.ber and indef_pr.ber files,
++indefinite length encodings are usually larger.
++
++
++
++Things to Note
++--------------
++
++Look at genber.C to see how to build a C++ value and then encode it.
++look at the example.C file to see buffer usage.  Look at
++.../c++_lib/inc/asn_config.h and .../c++_lib/inc/asn_buf.h if you
++want to change the buffer managment.
++
++
++Snacc ASN.1 comment commands
++
++Notice the special "--snacc" ASN.1 comment in .../asn1specs/p_rec.asn1.
++
++PersonnelRecord ::= --snacc isPdu:"TRUE" -- [APPLICATION 0] IMPLICIT SET
++ { ... etc. ... }
++
++The "isPdu" flag tells snacc that the PersonnelRecord is a PDU type.
++This flag has no effect on the generated C++ code, since each type gets
++PDU members automatically for C++.
++
++
++
++Length formats
++
++Both the def and indef programs were generated from the same source
++file, example.c.  Indefinite length encoders can be created by giving
++the -DUSE_INDEF_LEN flag to the C++ compiler when compiling.  Currently
++the indefinite/definite length encoder choice is made a compile time.
++To change this to a run-time decision, a simple solution would be to
++modify BerEncodeConsLen and BerEncodeEocIfNec macros in
++.../c++_lib/inc/asn_len.h to check a global flag.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1994/10/08 04:43:46  rj
++# the test csh skript has been integrated into the makefile
++#
++# Revision 1.1  1994/08/31  08:48:05  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c++-examples/simple/example.C snacc-1.3b4/c++-examples/simple/example.C
+--- snacc-1.3bbn/c++-examples/simple/example.C	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/simple/example.C	1995-07-24 15:36:03.000000000 +0000
+@@ -0,0 +1,115 @@
++// c++_examples/simple/example.C - an example of how to use  C++ ASN.1-BER
++//             encoders and decoders generated by snacc
++//
++// AUTHOR: Mike Sample
++// DATE:   Aug 92
++//
++// $Header$
++// $Log$
++// Revision 1.5  1995/07/24 15:36:03  rj
++// check return value of new.
++//
++// changed `_' to `-' in file names.
++//
++// Revision 1.4  1995/02/18  13:54:18  rj
++// added #define HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS since not every C++ compiler provides them.
++//
++// Revision 1.3  1994/10/08  01:27:02  rj
++// several \size_t'
++//
++// Revision 1.2  1994/08/31  08:56:32  rj
++// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++//
++
++#include <stddef.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <fstream.h>
++#include "asn-incl.h"
++#include "p-rec.h"
++
++
++main (int argc, char *argv[])
++{
++    AsnBuf  inputBuf;
++    AsnBuf  outputBuf;
++    size_t encodedLen;
++    size_t decodedLen;
++    size_t      dataSize;
++    ifstream dataFile;
++    PersonnelRecord pr;
++
++    if (argc != 2)
++    {
++        cerr << "Usage: " << argv[0] << " <BER data file name>" << endl;
++        cerr << "   Decodes the given PersonnelRecord BER data file" << endl;
++        cerr << "   and re-encodes it to stdout" << endl;
++        exit (1);
++    }
++
++
++    // open the data file
++    dataFile.open (argv[1]);
++
++    if (!dataFile)
++    {
++        perror ("ifstream::open");
++        exit (1);
++    }
++
++    // get size of the data file file
++    dataFile.seekg (0, ios::end);
++    dataSize = dataFile.tellg();
++    dataFile.seekg (0);
++
++    // read data from file into contiguous block for a buffer
++#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
++    char data[dataSize];
++#else
++    char *data = new char[dataSize];
++    if (!data)
++	return 1;
++#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
++    dataFile.read (data, dataSize);
++    dataFile.close();
++
++    //
++    // put the BER data read from the file
++    // into buffer format, ready for reading from the
++    // beginning
++    //
++    inputBuf.InstallData (data, dataSize);
++
++    if (!pr.BDecPdu (inputBuf, decodedLen))
++    {
++        cerr << "--- ERROR - Decode routines failed, exiting..." << endl;
++        exit (1);
++    }
++
++    cerr  << "decodedValue PersonnelRecord ::= " << pr << endl << endl;
++
++    //
++    // allocate a new buffer set up for writing to
++    //
++#if HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS
++    char outputData[dataSize + 512];
++#else
++    char *outputData = new char[dataSize + 512];
++    if (!outputData)
++	return 1;
++#endif /* HAVE_VARIABLE_SIZED_AUTOMATIC_ARRAYS */
++    outputBuf.Init (outputData, dataSize+512);
++    outputBuf.ResetInWriteRvsMode();
++
++    if (!pr.BEncPdu (outputBuf, encodedLen))
++    {
++        cerr << "--- ERROR - Encode routines failed" << endl;
++    }
++
++    // write the BER value to cout
++    outputBuf.ResetInReadMode();
++    for (; encodedLen > 0; encodedLen--)
++        cout.put (outputBuf.GetByte());
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c++-examples/simple/genber.C snacc-1.3b4/c++-examples/simple/genber.C
+--- snacc-1.3bbn/c++-examples/simple/genber.C	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/simple/genber.C	1995-07-24 15:40:32.000000000 +0000
+@@ -0,0 +1,99 @@
++// file: .../c++examples/simple/genber.C---builds an PersonnelRecord value and writes BER form of the value to a file called "pr.ber"
++//
++// MS 92
++//
++// $Header$
++// $Log$
++// Revision 1.5  1995/07/24 15:40:32  rj
++// changed `_' to `-' in file names.
++//
++// Revision 1.4  1994/12/11  15:36:14  rj
++// const for a constant value [DEC]
++//
++// Revision 1.3  1994/10/08  01:27:03  rj
++// several \size_t'
++//
++// Revision 1.2  1994/08/31  08:56:33  rj
++// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++//
++
++
++#include <stddef.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <fstream.h>
++
++#include "asn-incl.h"
++#include "p-rec.h"
++
++
++main (int argc, char *argv[])
++{
++    ofstream outputFile;
++    AsnBuf outputBuf;
++    size_t encodedLen;
++    const size_t dataSize = 1024;
++    char data[dataSize];
++    ChildInformation *ciPtr;
++    PersonnelRecord pr;
++
++    // build internal value of a PersonnelRecord
++    pr.name = new Name;
++    pr.name->givenName = "John";  // this calls pr.name->givenName.Set ("John");
++    pr.name->initial = "E";
++    pr.name->familyName = "Smith";
++
++    pr.title.Set ("The Big Cheese");
++    pr.employeeNumber = 99999;
++    pr.dateOfHire.Set ("19820104");
++
++    pr.nameOfSpouse = new Name;
++    pr.nameOfSpouse->givenName.Set ("Mary");
++    pr.nameOfSpouse->initial.Set ("L");
++    pr.nameOfSpouse->familyName.Set ("Smith");
++
++    pr.children = new PersonnelRecordSeqOf;
++
++    ciPtr = pr.children->Append();
++    ciPtr->name = new Name;
++    ciPtr->name->givenName.Set ("James");
++    ciPtr->name->initial.Set ("R");
++    ciPtr->name->familyName.Set ("Smith");
++    ciPtr->dateOfBirth.Set ("19570310");
++
++    ciPtr = pr.children->Append();
++    ciPtr->name = new Name;
++    ciPtr->name->givenName.Set ("Lisa");
++    ciPtr->name->initial.Set ("M");
++    ciPtr->name->familyName.Set ("Smith");
++    ciPtr->dateOfBirth.Set ("19610621");
++
++
++    // set up buffer for writing to
++    outputBuf.Init (data, dataSize);
++    outputBuf.ResetInWriteRvsMode();
++
++    // encode the internal value we just build into the buffer
++    if (!pr.BEncPdu (outputBuf, encodedLen))
++        cout << "failed encoding AnyTestType value" << endl;
++
++    // open file to hold the BER value
++    outputFile.open ("pr.ber");
++    if (!outputFile)
++    {
++        perror ("ofstream::open");
++        exit (1);
++    }
++
++    // copy the BER value from the buffer to the file
++    outputBuf.ResetInReadMode();
++    for (; encodedLen > 0; encodedLen--)
++        outputFile.put (outputBuf.GetByte());
++
++
++    cout << "Wrote the following BER PersonnelRecord value to pr.ber." << endl;
++    cout << "Test it with \"def\" and \"indef\"." << endl;
++    cout << pr << endl;
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c++-examples/simple/good-pr.ber.uu snacc-1.3b4/c++-examples/simple/good-pr.ber.uu
+--- snacc-1.3bbn/c++-examples/simple/good-pr.ber.uu	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/simple/good-pr.ber.uu	2005-07-30 16:55:52.183500816 +0000
+@@ -0,0 +1,7 @@
++begin 644 good-pr.ber
++M8(&,81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E0@,!AI^A
++M"D,(,3DX,C`Q,#2B$F$0%@1-87)Y%@%,%@53;6ET:*-!,1]A$18%2F%M97,6
++M`5(6!5-M:71HH`I#"#$Y-3<P,S$P,1YA$!8$3&ES818!318%4VUI=&B@"D,(
++(,3DV,3`V,C$`
++`
++end
+diff -uraN snacc-1.3bbn/c++-examples/simple/makefile snacc-1.3b4/c++-examples/simple/makefile
+--- snacc-1.3bbn/c++-examples/simple/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/simple/makefile	1997-02-16 16:47:58.000000000 +0000
+@@ -0,0 +1,146 @@
++# c++-examples/simple/makefile
++#
++# WARNING: this makefile isn't safe for parallel making!
++#
++# $Header$
++# $Log$
++# Revision 1.9  1997/02/16 16:47:58  rj
++# made return *this after calling abort()'' a compile time option.
++#
++# Revision 1.8  1995/07/24  15:29:44  rj
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.7  1995/02/20  11:47:37  rj
++# build snacc if it doesn't exist.
++# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
++#
++# Revision 1.6  1995/02/13  14:58:14  rj
++# augment CPPFLAGS, not overwrite
++#
++# Revision 1.5  1994/10/08  04:35:59  rj
++# enhance portability by using standard make capabilities instead of utilies (basename, dirname) not found on every platform.
++#
++# for the dependencies, generate the snacc compiler if it doesn't exist.
++#
++# Revision 1.4  1994/09/01  02:26:54  rj
++# use CXX instead of CC to get another default linkage
++#
++# Revision 1.3  1994/08/31  21:40:00  rj
++# rebuild the executables when the c++-lib is newer.
++# the file good-pr.ber needs to be distributed.
++#
++# Revision 1.2  1994/08/31  10:31:50  rj
++# since .o files get moved, a few more dependencies are needed.
++#
++# Revision 1.1  1994/08/31  08:48:10  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SRC_DIR	= $(TOP)/asn1specs
++
++ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
++ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
++ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
++SNACCFLAGS	= -C $(SNACC_NOVOLAT) -u $(USEFUL_TYPES)
++
++CC		= $(CXX)
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR) $(LENFLAG)
++
++ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
++
++# generated by snacc from p-rec.asn1:
++ASN1HFILES	= p-rec.h
++ASN1CFILES	= p-rec.C
++
++CFILES = \
++	genber.C	\
++	example.C
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)	\
++	good-pr.ber
++
++#-------------------------------------------------------------------------------
++
++all::		genber def indef
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++def-obj		\
++indef-obj:
++		mkdir $@
++
++def-obj/p-rec.o	\
++def-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++indef-obj/p-rec.o	\
++indef-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++genber:		def-obj/p-rec.o genber.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ def-obj/p-rec.o genber.o $(ASN1_C++_LIB) $(LIBS)
++
++def: 		def-obj/p-rec.o def-obj/example.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ def-obj/p-rec.o def-obj/example.o $(ASN1_C++_LIB) $(LIBS)
++
++indef:		indef-obj/p-rec.o indef-obj/example.o
++		$(REASON)
++		$(CXX) $(LDFLAGS) -o $@ indef-obj/p-rec.o indef-obj/example.o $(ASN1_C++_LIB) $(LIBS)
++
++genber	\
++def	\
++indef:		$(ASN1_C++_LIB)
++
++.PHONY:	check
++
++check::		def indef
++		$(RM) foo.ber bar.ber
++		./indef good-pr.ber > foo.ber
++		./def foo.ber > bar.ber
++		@if cmp -s bar.ber good-pr.ber; then\
++		  echo "+++ Passed simple encode/decode tests using p-rec.asn1.";\
++		else\
++		  echo "--- Failed simple encode/decode tests using p-rec.asn1.";\
++		fi
++		$(RM) foo.ber bar.ber
++
++clean::
++		$(RM) *.o *~ .emacs* core def indef genber pr.ber $(ASN1HFILES) $(ASN1CFILES)
++		$(RM) -r def-obj indef-obj
++		$(RM) foo.ber bar.ber
++
++depend::	$(SNACC)
++
++include ../../maketail
++
++depend::
++		cp dependencies deps
++		for dir in def-obj indef-obj; do\
++		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
++		done
++		mv deps dependencies
+diff -uraN snacc-1.3bbn/c++-examples/snmp/README snacc-1.3b4/c++-examples/snmp/README
+--- snacc-1.3bbn/c++-examples/snmp/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/snmp/README	1995-07-27 11:36:13.000000000 +0000
+@@ -0,0 +1,126 @@
++(RCS control information is at the end of this file.)
++
++
++C++ SNMP Example - Mike Sample Mar 92
++---------------------------------
++
++This example illustrates a few more features of the compiler than the
++simple example.  It also shows some deficiencies.  No executable
++programs are generated by the makefile, it only generates the snmp
++code and compiles it without linking.
++
++This directory contains 2 files:
++        README
++        makefile
++
++Snacc generates source from the following ASN.1 files:
++        .../asn1specs/rfc1155-smi.asn1
++        .../asn1specs/rfc1157-snmp.asn1
++        .../asn1specs/rfc1213-mib2.asn1
++
++multi-module compilation
++   The IMPORT/EXPORT mechanisms of ASN.1 '88 are supported so you don't
++   have to dump all of the ASN.1 definitions into a single file
++   The order of the ASN.1 file arguments is the order that they
++   are included in the generated source files.  For example:
++
++   %1 snacc rfc1155-smi.asn1 rfc1157-snmp.asn1 rfc1213-mib2.asn1
++
++   causes the order in which hdr files are included in rfc1213-mib2.C
++   to be:
++
++   #include "asn-incl.h"
++   #include "rfc1155-smi.h"
++   #include "rfc1157-snmp.h"
++   #include "rfc1213-mib2.h"
++
++
++    Currently, snacc assumes that each ASN.1 file given on the command
++    line depends on all of the others on the command line.  There is
++    no attempt to compute the dependencies via the import lists alone.
++
++SNMP OBJECT-TYPE macro parsing / ANY type hash table
++   The SNMP OBJECT-TYPE macro is parsed.   This results in the
++   type in the "SYNTAX" part of the macro is put into
++   the ANY type hash table using the  OBJECT-TYPE macro's value as the
++   hash key.  Also if the type in the SYNTAX field is not defined
++   outsided of the macro (could be different tagging etc), a proper
++   type definition is generated for it.  If you want to change the way
++   the macro is handled, modify the corresponding routine in "do_macros.c".
++
++value definitions
++   The OBJECT IDENTIFIER values are turned into statically initialized
++   C++ values and included in the generated source and include file.  This
++   is also done for INTEGER and BOOLEAN values.  More complex values
++   are ignored by the compiler at the moment. (modify parse_vals.c if
++   you want to improve this)
++
++
++-P option of snacc is demonstrated
++   The ASN.1 for the parsed modules is generated from the internal data
++   structure.  This can be useful for making sure the compiler is
++   handling your ASN.1 files correctly.  It is also useful to see how
++   the types are modified and sorted to simplify code generation.
++   (see the file snacc.output after typeing "make")
++
++Deficiencies
++   A deficiency in parsing large integers is shown when parsing the
++   following rfc 1155 types:
++
++                  Counter ::=
++                      [APPLICATION 1]
++                          IMPLICIT INTEGER (0..4294967295)
++
++                  Gauge ::=
++                      [APPLICATION 2]
++                          IMPLICIT INTEGER (0..4294967295)
++
++                  TimeTicks ::=
++                      [APPLICATION 3]
++                          IMPLICIT INTEGER (0..4294967295)
++
++Due the size of a C long int the above ASN.1 is represented internally as:
++
++Counter ::= [APPLICATION 1] IMPLICIT INTEGER (0..-1)
++
++Gauge ::= [APPLICATION 2] IMPLICIT INTEGER (0..-1)
++
++TimeTicks ::= [APPLICATION 3] IMPLICIT INTEGER (0..-1)
++
++The ASN.1 library contains routines for encoding/decoding unsigned
++long integers but you must hand code the cases where it is used - the
++compiler never generates code that calls them.
++
++Note also that the produced code for the SNMP ASN.1 must be modified
++to correclty handle the "Opaque" data type.  SNMP does not use the ANY
++DEFINED BY type in an effort to simplify things.  Instead an OCTET
++STRING is used to hold and encoded value whose type is defined by an
++OBJECT IDENTIFIER.  With some simple modifications you can use the
++snacc AsnAnyDefinedBy type instead of the OCTET STRING to achieve
++the desired results.
++
++This should underline the danger of blindly trusting the compiler to
++do the right thing for protocols such as SNMP or X.500 where the type
++of an encoded value depends on a mechanism outside of ASN.1 or the ANY
++type (ANY DEFINED BY types should work automatically).
++
++There is a problem when generating C++ code with the SNMP ASN.1 files.
++Several of the ASN.1 value names conflict with C++ keywords.  The
++generated code will not compile properly as a result.  The best way to
++fix these is to modify the ASN.1 files directly.  The compiler will
++munge field or type names to avoid conflicts with the target language
++but currently does not check value names.  The SNMP ASN.1 module shows
++this problem the with value "private" in rfc1155-smi.asn1.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.3  1995/07/27 11:36:13  rj
++# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
++#
++# Revision 1.2  1995/07/24  15:41:22  rj
++# changed `_' to `-' in file names.
++#
++# Revision 1.1  1994/08/31  08:48:13  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c++-examples/snmp/makefile snacc-1.3b4/c++-examples/snmp/makefile
+--- snacc-1.3bbn/c++-examples/snmp/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/snmp/makefile	1997-02-16 16:48:08.000000000 +0000
+@@ -0,0 +1,103 @@
++# c++-examples/snmp/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.10  1997/02/16 16:48:08  rj
++# made return *this after calling abort()'' a compile time option.
++#
++# Revision 1.9  1995/07/27  11:59:01  rj
++# rfc1213-mib -> rfc1213-mib2
++#
++# Revision 1.8  1995/07/27  08:29:58  rj
++# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
++#
++# Revision 1.7  1995/07/24  15:30:11  rj
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.6  1995/02/20  11:48:41  rj
++# build snacc if it doesn't exist.
++#
++# Revision 1.5  1995/02/13  14:58:15  rj
++# augment CPPFLAGS, not overwrite
++#
++# Revision 1.4  1994/10/08  04:36:28  rj
++# for the dependencies, generate the snacc compiler if it doesn't exist.
++#
++# Revision 1.3  1994/09/01  02:26:56  rj
++# use CXX instead of CC to get another default linkage
++#
++# Revision 1.2  1994/08/31  23:25:41  rj
++# print a less irritating usage.
++#
++# Revision 1.1  1994/08/31  08:48:14  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SPEC_DIR	= $(TOP)/asn1specs
++
++ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
++ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
++ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++
++CC		= $(CXX)
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR)
++
++ASN1FILES = \
++	$(ASN1_SPEC_DIR)/rfc1155-smi.asn1	\
++	$(ASN1_SPEC_DIR)/rfc1157-snmp.asn1	\
++	$(ASN1_SPEC_DIR)/rfc1213-mib2.asn1
++
++ASN1HFILES = \
++	rfc1155-smi.h	\
++	rfc1213-mib2.h	\
++	rfc1157-snmp.h
++
++ASN1CFILES = \
++	rfc1155-smi.C	\
++	rfc1213-mib2.C	\
++	rfc1157-snmp.C
++
++DISTFILES = \
++	README		\
++	makefile	\
++
++#-------------------------------------------------------------------------------
++
++default::	warning
++
++warning::
++		@echo ''
++		@echo 'read the README and enter `$(MAKE) fail` to test for yourself'
++		@echo ''
++
++fail::		$(ASN1HFILES) $(ASN1CFILES)
++		$(CXX) $(CPPFLAGS) $(CFLAGS) -c $(ASN1CFILES)
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) -P -C $(SNACC_NOVOLAT) $(ASN1FILES) > snacc.output~
++		mv snacc.output~ snacc.output
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++check::
++		@echo "the purpose of this directories' contents is to show deficiencies."
++		@echo "if you want to exercise 'em, make the phony target "'`'"fail'"
++
++clean::
++		$(RM) *.o *~ .emacs* core $(ASN1HFILES) $(ASN1CFILES) snacc.output
++
++depend::	$(SNACC)
++
++include ../../maketail
+diff -uraN snacc-1.3bbn/c++-examples/test-lib/README snacc-1.3b4/c++-examples/test-lib/README
+--- snacc-1.3bbn/c++-examples/test-lib/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/test-lib/README	1997-02-16 20:25:29.000000000 +0000
+@@ -0,0 +1,37 @@
++(RCS control information is at the end of this file.)
++
++
++C++ test_lib README
++-------------------
++
++This directory should have 3 files:
++        README - this file
++        makefile
++        test_lib.C
++
++Type "make" to compile test_lib.
++
++test_lib tests each encode and decode routine in the C++ ASN.1
++runtime library. Errors will be reported.
++
++test_lib should be run for each machine architecture you install snacc on.
++If you modify the library routines you should run test_lib again.
++
++The general testing methodology is:
++        1. test the buffer routines
++        2. test tags
++        3. test lengths
++        4. test each libarary type.
++
++For each type, a range of values is encoded and then decoded
++and and compared with the original value.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1997/02/16 20:25:29  rj
++# check-in of a few cosmetic changes
++#
++# Revision 1.1  1994/08/31  08:48:16  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c++-examples/test-lib/makefile snacc-1.3b4/c++-examples/test-lib/makefile
+--- snacc-1.3bbn/c++-examples/test-lib/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/test-lib/makefile	1997-03-03 11:58:30.000000000 +0000
+@@ -0,0 +1,59 @@
++# c++-examples/test-lib/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.7  1997/03/03 11:58:30  wan
++# Final pre-delivery stuff (I hope).
++#
++# Revision 1.6  1997/02/28 13:39:41  wan
++# Modifications collected for new version 1.3: Bug fixes, tk4.2.
++#
++# Revision 1.5  1995/07/24 15:31:14  rj
++# changed `_' to `-' in file names.
++#
++# Revision 1.4  1995/02/13  14:58:17  rj
++# augment CPPFLAGS, not overwrite
++#
++# Revision 1.3  1994/09/01  02:26:58  rj
++# use CXX instead of CC to get another default linkage
++#
++# Revision 1.2  1994/08/31  21:44:25  rj
++# rebuild the executables when the c++-lib is newer.
++#
++# Revision 1.1  1994/08/31  08:48:17  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_C++_LIB_DIR	= $(TOP)/c++-lib
++ASN1_C++_INC_DIR	= $(ASN1_C++_LIB_DIR)/inc
++ASN1_C++_LIB		= $(ASN1_C++_LIB_DIR)/libasn1c++.a
++
++CC		= $(CXX)
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C++_INC_DIR)
++
++CFILES = \
++	test-lib.C
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)
++
++#-------------------------------------------------------------------------------
++
++default::	check
++
++check::		test-lib
++		./test-lib
++
++test-lib:	$(ASN1_C++_LIB) test-lib.o
++		$(CXX) $(LDFLAGS) -o $@ test-lib.o $(ASN1_C++_LIB) $(LIBS)
++
++clean::
++		$(RM) *.o *~ .emacs* test-lib core
++
++include ../../maketail
+diff -uraN snacc-1.3bbn/c++-examples/test-lib/test-lib.C snacc-1.3b4/c++-examples/test-lib/test-lib.C
+--- snacc-1.3bbn/c++-examples/test-lib/test-lib.C	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c++-examples/test-lib/test-lib.C	1997-02-28 13:39:42.000000000 +0000
+@@ -0,0 +1,781 @@
++// c++_examples/test_lib/test_lib.C
++//
++// $Header$
++// $Log$
++// Revision 1.5  1997/02/28 13:39:42  wan
++// Modifications collected for new version 1.3: Bug fixes, tk4.2.
++//
++// Revision 1.4  1995/07/24 15:44:10  rj
++// #error "..." instead of #error ...
++//
++// changed `_' to `-' in file names.
++//
++// function and file names adjusted.
++//
++// Revision 1.3  1995/02/18  16:40:08  rj
++// utilize either isinf(3) or finite(3), whatever happens to be present.
++//
++// Revision 1.2  1994/08/31  08:56:35  rj
++// first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++//
++
++#include <stdio.h>
++#include <iostream.h>
++#include "asn-incl.h"
++
++
++int TestAsnBuffers();
++int TestAsnTag();
++int TestAsnLen();
++int TestAsnBool();
++int TestAsnInt();
++int TestAsnReal();
++int TestAsnOcts();
++int TestAsnBits();
++int TestAsnOid();
++int TestAsnList();
++
++const int bufSize = 256;
++
++int main()
++{
++    int isErr = false;
++
++    if (!TestAsnBuffers())
++    {
++        cout << "Failed buffer tests, no point in proceeding ... bye!" << endl;
++        return 1;
++    }
++
++    if (!TestAsnTag())
++    {
++        cout << "Failed Tag test." << endl;
++        isErr = true;
++    }
++
++    if (!TestAsnLen())
++    {
++        cout << "Failed Length test." << endl;
++        isErr = true;
++    }
++
++    if (!TestAsnBool())
++    {
++        cout << "Failed BOOLEAN test." << endl;
++        isErr = true;
++    }
++
++
++    if (!TestAsnInt())
++    {
++        cout << "Failed INTEGER test." << endl;
++        isErr = true;
++    }
++
++    if (!TestAsnOcts())
++    {
++        cout << "Failed OCTET STRING test." << endl;
++        isErr = true;
++    }
++
++
++    if (!TestAsnBits())
++    {
++        cout << "Failed BIT STRING test." << endl;
++        isErr = true;
++    }
++
++
++    if (!TestAsnOid())
++    {
++        cout << "Failed OBJECT IDENTIFIER test." << endl;
++        isErr = true;
++    }
++
++
++    if (!TestAsnReal())
++    {
++        cout << "Failed REAL test." << endl;
++        isErr = true;
++    }
++
++
++
++    if (isErr)
++    {
++        cout << "There are errors in the primitive type encoding/decoding" << endl;
++        cout << "library for this architecture.  Time for gdb..." << endl;
++    }
++    else
++    {
++        cout << "The primitive type encoding/decoding library passed simple tests." << endl;
++        cout << "It should be safe to use..." << endl;
++    }
++    return isErr;
++}
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnBuffers()
++{
++    AsnBuf  b;
++    char bufData[256];
++    int i,j;
++    int noErr = true;
++
++    // initialize buffer
++    b.Init (bufData, 256);
++    b.ResetInWriteRvsMode();
++
++    // write whole range of byte (0..255)
++    // remember, write works in reverse
++    for (i = 0; i < 256; i++)
++        b.PutByteRvs (i);
++
++    if (b.WriteError())
++    {
++        cout << "Error writing to buffer." << endl;
++        noErr = false;
++    }
++
++    // read in values & verify
++    b.ResetInReadMode();
++    for (i = 255; i >= 0; i--)
++        if (b.GetByte() != i)
++        {
++            cout << "Error verifying data written to buffer." << endl;
++            noErr = false;
++        }
++
++    if (b.ReadError())
++    {
++        cout << "Error reading from buffer." << endl;
++        noErr = false;
++    }
++
++
++    /* now make sure errors are detected */
++    b.ResetInWriteRvsMode();
++
++    for (i = 0; i < 257; i++) // write past end of buffer
++        b.PutByteRvs (0);
++
++    if (!b.WriteError())
++    {
++        cout << "Buffers failed to report buffer write overflow." << endl;
++        noErr = false;
++    }
++
++
++    b.ResetInReadMode();
++    for (i = 256; i >= 0; i--)  // read past end of buffer
++        b.GetByte();
++
++    if (!b.ReadError())
++    {
++        cout << "Buffers failed to report buffer read overflow." << endl;
++        noErr = false;
++    }
++
++    return noErr;
++}  /* TestAsnBuffers */
++
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnTag()
++{
++    AsnTag aTag1;
++    AsnTag aTag2;
++    int i, j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = true;
++    ENV_TYPE env;
++    AsnBuf  b;
++    char bufData[256];
++    long int val;
++    BER_CLASS tagClass;
++    BER_FORM form;
++    BER_UNIV_CODE code;
++
++
++    /* initialize buffer */
++    b.Init (bufData, 256);
++
++    /* encode a TRUE value and verify */
++    tagClass = UNIV;
++    form = PRIM;
++    code = INTEGER_TAG_CODE;
++    aTag1 = MAKE_TAG_ID (tagClass, form, code);
++
++    for (i = 0; i < 2; i++)
++    {
++        b.ResetInWriteRvsMode();
++        len1 = BEncTag1 (b, tagClass, form, code);
++
++        if (b.WriteError())
++        {
++            noErr = false;
++            cout << "Error encoding a Tag." << endl;
++        }
++
++        b.ResetInReadMode();
++
++        aTag2 = 0;
++
++        /* make sure no decode errors and that it decodes to same tag */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            aTag2 = BDecTag (b, len2, env);
++        }
++        else
++        {
++            noErr = false;
++            cout << "Error decoding a Tag - error number " << val << endl;
++        }
++        if (noErr && ((aTag2 != aTag1) || (len1 != len2)))
++        {
++            noErr = false;
++            cout << "Error decoded Tag does not match encoded Tag." << endl;
++        }
++        /* set a new test tag value */
++        tagClass = CNTX;
++        form = CONS;
++        code = (BER_UNIV_CODE) 29;
++        aTag1 = MAKE_TAG_ID (tagClass, form, code);
++    }
++    return noErr;
++}  /* TestAsnTag */
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnLen()
++{
++    AsnLen aLen1;
++    AsnLen aLen2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = true;
++    ENV_TYPE env;
++    AsnBuf  b;
++    char bufData[256];
++    long int val;
++
++    /* initialize buffer */
++    b.Init (bufData, 256);
++
++
++    /* encode a TRUE value and verify */
++    aLen1 = 99999;
++    for (i = 0; i < 2; i++)
++    {
++        b.ResetInWriteRvsMode();
++        len1 = BEncDefLen (b, aLen1);
++
++        if (b.WriteError())
++        {
++            noErr = false;
++            cout <<  "Error encoding Length." << endl;
++        }
++
++        b.ResetInReadMode();
++
++        aLen2 = 0;
++
++        /* make sure no decode errors and that it decodes to true */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            aLen2 = BDecLen (b, len2, env);
++        }
++        else
++        {
++            noErr = false;
++            cout << "Error decoding Length - error number " << val << endl;
++        }
++
++
++        if (noErr && ((aLen2 != aLen1) || (len1 != len2)))
++        {
++            noErr = false;
++            cout << "Error - decoded length does not match encoded length" << endl;
++        }
++        aLen1 = 2;
++    }
++
++
++    /* test indef len */
++    b.ResetInWriteRvsMode();
++    len1 = BEncIndefLen (b);
++
++    if (b.WriteError())
++    {
++        noErr = false;
++        cout << "Error encoding indefinite Length." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    aLen2 = 0;
++
++    /* make sure no decode errors */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        aLen2 = BDecLen (b, len2, env);
++    }
++    else
++    {
++        noErr = false;
++        cout << "Error decoding Length - error number " << val << endl;
++    }
++
++
++    if (noErr && ((aLen2 != INDEFINITE_LEN) || (len1 != len2)))
++    {
++        noErr = false;
++        cout << "Error - decoded length does not match encoded length" << endl;
++    }
++
++    /* test EOC */
++    b.ResetInWriteRvsMode();
++    len1 = BEncEoc (b);
++
++    if (b.WriteError())
++    {
++        noErr = false;
++        cout << "Error encoding indefinite Length." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    aLen2 = 0;
++
++    /* make sure no decode errors */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecEoc (b, len2, env);
++    }
++    else
++    {
++        noErr = false;
++        cout << "Error decoding Length - error number " <<  val << endl;
++    }
++
++
++    if (noErr && (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error - decoded EOC length error" << endl;
++    }
++
++    return noErr;
++}  /* TestAsnLen */
++
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnBool()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnBool aBool1;
++    AsnBool aBool2;
++    int j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++    b.ResetInWriteRvsMode();
++
++    // encode a true value and verify
++    aBool1 = true;
++
++    if (!aBool1.BEncPdu (b, len1))
++    {
++        noErr = false;
++        cout << "Error encoding TRUE BOOLEAN value." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    aBool2 = false; // set to opposite of expected value
++
++    // make sure no decode errors and that it decodes to true
++    if (!aBool2.BDecPdu (b, len2) || !aBool2 || (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error decoding TRUE BOOLEAN value." << endl;
++    }
++
++    // now encode a false value and verify
++    b.ResetInWriteRvsMode();
++    aBool1 = false;
++
++    if (!aBool1.BEncPdu (b, len1))
++    {
++        noErr = false;
++        cout << "Error encoding FALSE BOOLEAN value." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    aBool2 = true; // set to opposite of expected value
++
++    // make sure no decode errors and that it decodes to false
++    if (!aBool2.BDecPdu (b, len2) || aBool2 || (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error decoding FALSE BOOLEAN value." << endl;
++    }
++
++    return noErr;
++}  /* TestAsnBool */
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnInt()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnInt a1;
++    AsnInt a2;
++    int i,j, sign;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++
++    //
++    // Encode a range of integers: negative & positive in
++    //  the 1 to sizeof (long int) range
++    //
++
++    sign = 1;
++    for (j = 0; j < 2; j++)
++    {
++        for (i = 0; i < sizeof (long int); i++)
++        {
++            b.ResetInWriteRvsMode();
++
++            a1 = sign * (17 << (i * 8)); // 17 is a random choice
++            if (!a1.BEncPdu (b, len1))
++            {
++                noErr = false;
++                cout << "Error encoding INTEGER value " << a1 << "." << endl;
++            }
++
++            b.ResetInReadMode();
++            a2 = 0;
++
++            // make sure no decode errors and that it decodes to the correc val
++            if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
++            {
++                noErr = false;
++                cout << "Error decoding INTEGER value " << a1 << "." << endl;
++            }
++        }
++        sign = -1;
++    }
++
++    return noErr;
++
++} /* TestAsnInt */
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnOcts()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnOcts a1;
++    AsnOcts a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++
++    a1 = "Hello Gumby?";
++    for (j = 0; j < 2; j++)
++    {
++        b.ResetInWriteRvsMode();
++
++        if (!a1.BEncPdu (b, len1))
++        {
++            noErr = false;
++            cout << "Error encoding OCTET STRING value " << a1 << "." << endl;
++        }
++
++        b.ResetInReadMode();
++
++        // make sure no decode errors and that it decodes to the correc val
++        if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
++        {
++            noErr = false;
++            cout << "Error decoding OCTET STRING value " << a1 << "." << endl;
++        }
++        a1 = ""; // try an empty string
++    }
++
++    return noErr;
++
++} /* TestAsnOcts */
++
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnBits()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnBits a1 (32);
++    AsnBits a2 (32);
++    short bitsToSet[32] = { 0, 1, 0, 0, 1, 1, 0, 1,
++                            0, 1, 0, 0, 1, 1, 0, 1,
++                            0, 1, 0, 0, 1, 1, 0, 1,
++                            0, 1, 0, 0, 1, 1, 0, 1 };
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++
++
++    // set some bits
++    for (i = 0; i < 32; i++)
++    {
++        if (bitsToSet[i])
++            a1.SetBit (i);
++        else
++            a1.ClrBit (i);
++
++    }
++
++    b.ResetInWriteRvsMode();
++    if (!a1.BEncPdu (b, len1))
++    {
++        noErr = false;
++        cout << "Error encoding BIT STRING value " << a1 << "." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    // make sure no decode errors and that it decodes to the correc val
++    if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error decoding BIT STRING value " << a1 << "." << endl;
++    }
++
++
++    return noErr;
++
++} /* TestAsnBits */
++
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnOid()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnOid a1 (0,1,2,3,4,5,6);
++    AsnOid a2;
++    AsnOid a3 (2,38,29,40,200,10,4000);
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++
++    for (i = 0; i < 2; i++)
++    {
++        b.ResetInWriteRvsMode();
++
++        if (!a1.BEncPdu (b, len1))
++        {
++            noErr = false;
++            cout << "Error encoding OBJECT IDENTIFIER value " << a1 << "." << endl;
++        }
++
++        b.ResetInReadMode();
++
++        // make sure no decode errors and that it decodes to the correc val
++        if (!a2.BDecPdu (b, len2) || (a2 != a1) || (len1 != len2))
++        {
++            noErr = false;
++            cout << "Error decoding OBJECT IDENTIFIER value " << a1 << "." << endl;
++        }
++
++        a1 = a3;
++    }
++    return noErr;
++
++} /* TestAsnOid */
++
++/*
++ * returns true if passes encode/decode tests
++ *
++ * NOT USED - nuked template design.
++ */
++/*
++int
++TestAsnList()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnList<AsnInt> intList1;
++    AsnList<AsnInt> intList2;
++    AsnList<AsnBool> boolList1;
++    AsnList<AsnBool> boolList2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++    b.Init (bufData, bufSize);
++
++    b.ResetInWriteRvsMode();
++
++    if (!intList1.BEncPdu (b, len1))
++    {
++        noErr = false;
++        cout << "Error encoding SEQUENCE OF value " << intList1 << "." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    if (!intList2.BDecPdu (b, len2) || (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error decoding SEQUENCE OF value " << intList1 << "." << endl;
++    }
++    cout << "intlist 1 = "  <<  intList1 << endl;
++    cout << "intlist 2 = "  <<  intList1 << endl;
++
++
++    if (!boolList1.BEncPdu (b, len1))
++    {
++        noErr = false;
++        cout << "Error encoding SEQUENCE OF value " << boolList1 << "." << endl;
++    }
++
++    b.ResetInReadMode();
++
++    if (!boolList2.BDecPdu (b, len2) ||  (len1 != len2))
++    {
++        noErr = false;
++        cout << "Error decoding SEQUENCE OF value " << boolList1 << "." << endl;
++    }
++    cout << "boolList 1 = "  <<  boolList1 << endl;
++    cout << "boolList 2 = "  <<  boolList1 << endl;
++
++    return noErr;
++
++}  TestAsnList */
++
++
++
++/*
++ * returns true if passes encode/decode tests
++ */
++int
++TestAsnReal()
++{
++    AsnBuf  b;
++    char bufData[bufSize];
++    AsnReal  a2;
++    AsnReal  a[] = { 0.0, 0.8, -22.484848, PLUS_INFINITY, MINUS_INFINITY};
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    int noErr = true;
++
++
++    /*
++     * if you do not have the ieee_functions in your math lib,
++     * this will not link.  Comment it out and cross you fingers.
++     * (or check/set the +/-infinity values for you architecture)
++     */
++#if HAVE_ISINF
++    if (!isinf ((double)PLUS_INFINITY)) || !isinf ((double)MINUS_INFINITY))
++#else
++#if HAVE_FINITE
++    if (finite ((double)PLUS_INFINITY) || finite ((double)MINUS_INFINITY))
++#else
++  #error "oops: you've got neither isinf(3) nor finite(3)?!"
++#endif
++#endif
++    {
++        cout << "WARNING: PLUS_INFINITY and MINUS_INFINITY in .../c++-lib/src/asn-real.C are" << endl;
++        cout << "not correct for this architecture.  Modify the AsnPlusInfinity() routine." << endl;
++    }
++
++
++    // initialize a small buffer
++    b.Init (bufData, bufSize);
++
++    for (i = 0; i < 5; i++)
++    {
++        b.ResetInWriteRvsMode();
++
++        if (!a[i].BEncPdu (b, len1))
++        {
++            noErr = false;
++            cout << "Error encoding REAL value " << a[i] << "." << endl;
++        }
++
++        b.ResetInReadMode();
++
++        // make sure no decode errors and that it decodes to the correc val
++        if (!a2.BDecPdu (b, len2) || (a2 != a[i]) || (len1 != len2))
++        {
++            noErr = false;
++            cout << "Error decoding REAL value " << a[i] << "." << endl;
++        }
++    }
++
++    return noErr;
++
++} /* TestAsnReal */
+diff -uraN snacc-1.3bbn/c-examples/any/README snacc-1.3b4/c-examples/any/README
+--- snacc-1.3bbn/c-examples/any/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/any/README	1997-02-16 20:26:14.000000000 +0000
+@@ -0,0 +1,107 @@
++(RCS control information is at the end of this file.)
++
++
++C ANY example README
++------------------
++
++This example shows how the snacc compiler handles the ANY DEFINED BY
++type in C.  ANY types (not ANY DEFINED BY) require the modifications
++to the generated code.  Type "make" to build this example.
++
++This directory should have the following files in it:
++
++        README
++        genber.c
++        example.c
++        makefile
++
++There are 3 programs generated by the makefile:
++
++        genber - builds a BER value of the AnyTestType and writes it
++                 to a file called "att.ber"
++
++        def    - takes file name of an AnyTestType value.  Decodes the
++                 file and re-encodes it to stdout.  Uses definite
++                 lengths for constructed values.
++
++        indef  - takes file name of an AnyTestType value.  Decodes the
++                 file and re-encodes it to stdout.  Uses indefinite
++                 lengths for constructed values.
++
++
++These files use the code generated by snacc from the
++snacc/asn1specs/any.asn1 file. (see the makefile)
++
++Look at genber.c to see how values can be built and printed.
++
++Look at the generated code in any_test.c and any_test.h to see how the
++any hash table is built.
++
++
++try the following commands in your c-shell:
++
++%1 genber                   # generate the att.ber file
++%2 indef att.ber > tmp.ber  # decode att.ber an re-encode into tmp.ber
++%3 def tmp.ber > tmp2.ber   # decode tmp.ber an re-encode into tmp2.ber
++%4 diff att.ber tmp2.ber    # compare .ber files (should be the same)
++
++When you are finished with the example type "make clean"  to remove
++the binaries and generated code.
++
++
++
++Things To Note
++--------------
++
++Snacc ASN.1 comment commands
++
++In the snacc/asn1specs/any.asn1 file, the AnyTestType has a special
++"--snacc" ASN.1 comment after ::= to give snacc some extra information
++about the AnyTestType.
++
++AnyTestType ::= --snacc isPdu:"TRUE" -- SEQUENCE { ... etc. ... }
++
++The "isPdu" flag tells snacc that the AnyTestType is a PDU type that
++you will be calling the encoding and decoding routines directly
++from your code.  This causes snacc to generate the "BEncAnyTestType"
++and "BDecAnyTestType" routines in addition to the standard
++"BEncAnyTestTypeContent" and "BDecAnyTestTypeContent".
++
++The Content encoding and decoding routines only deal with the content
++of the type, ignoring all of the tag and length pairs on the given
++type (in this case the UNIVERSAL (CONSTRUCTED) 16 tag and the length
++for the SEQUENCE).  The "BEncAnyTestType" and "BDecAnyTestType"
++routines do encode the SEQUENCE tag and its length.  This design is
++motivated by IMPLICIT tagging.
++
++The compiler generated routines generally only call the content
++oriented routines except in the case of ANY and ANY DEFINED BY types.
++For ANY and ANY DEFINED BY types the PDU form of the rouine is called
++since the tags are not known by the containing type.
++
++
++SNMP OBJECT-TYPE Macro
++
++The SNMP OBJECT-TYPE macro is used to define the id to type mapping
++for ANY DEFINED BY types.  The macro has been modified to accept both
++INTEGERs and OBJECT IDENTIFIERs as values (see
++snacc/asn1specs/any.asn1).  This macro can be used with other
++protocols to define the id to type mapping.
++
++Two hash tables are used to hold the id to type mappings. One for
++INTEGER to type mappings and the other for OBJECT IDENTIFIER to type
++mappings.  You must explicitly initialize the hash tables by calling
++generated init routines once at the beginning of your program.  Each
++module that has OBJECT-TYPE macros in it will generate an
++"InitAny<module name>" routine.  You must call every init routine to
++add all the mappings to the hash table(s).
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1997/02/16 20:26:14  rj
++# check-in of a few cosmetic changes
++#
++# Revision 1.1  1994/08/31  08:46:17  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c-examples/any/example.c snacc-1.3b4/c-examples/any/example.c
+--- snacc-1.3bbn/c-examples/any/example.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/any/example.c	1997-02-16 20:26:15.000000000 +0000
+@@ -0,0 +1,161 @@
++/*
++ * c-examples/any/example.c - an example of how to call C ASN.1-BER
++ *             encoders and decoders generated by snacc
++ *
++ * AUTHOR: Mike Sample
++ * DATE:   Mar 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.6  1997/02/16 20:26:15  rj
++ * check-in of a few cosmetic changes
++ *
++ * Revision 1.5  1995/07/24  20:40:19  rj
++ * any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
++ *
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  15:17:35  rj
++ * cosmetic changes
++ *
++ * Revision 1.3  1994/08/31  23:45:45  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:31  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include "asn-incl.h"
++
++#include <sys/types.h>
++#include <sys/stat.h>
++#if HAVE_FCNTL_H
++#include <fcntl.h>
++#endif
++#include <stdio.h>
++
++#include "any.h"
++
++
++
++main PARAMS ((argc, argv),
++    int argc _AND_
++    char *argv[])
++{
++    int fd;
++    SBuf  buf;
++    SBuf  encBuf;
++    char *encData;
++    AsnLen encodedLen;
++    AsnLen decodedLen;
++    int     val;
++    AnyTestType att;
++    int      size;
++    char    *origData;
++    struct stat sbuf;
++    jmp_buf env;
++
++    if (argc != 2)
++    {
++        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
++        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
++        fprintf (stderr, "   and re-encodes it to stdout\n");
++        exit (1);
++    }
++
++    fd = open (argv[1], O_RDONLY, 0);
++    if (fd < 0)
++    {
++        perror ("main: fopen");
++        exit (1);
++    }
++
++    if (fstat (fd, &sbuf) < 0)
++    {
++        perror ("main: fstat");
++        exit (1);
++    }
++
++    size = sbuf.st_size;
++    origData = (char*)malloc (size);
++    if (read (fd, origData, size) != size)
++    {
++        perror ("main: read");
++        exit (1);
++    }
++
++    close (fd);
++
++    /*
++     * puts the given data 'origData' of 'size' bytes
++     * into an SBuf and sets the SBuf up for reading
++     * origData from the beginning
++     */
++    SBufInstallData (&buf, origData, size);
++
++    /*
++     * the first argument (512) is the number of bytes to
++     * initially allocate for the decoder to allocate from.
++     * The second argument (512) is the size in bytes to
++     * enlarge the nibble memory by when it fills up
++     */
++    InitNibbleMem (512, 512);
++
++
++    /*
++     * initialize the hash table for the
++     * the ANY type mappings.
++     * This only needs to be done once per execution
++     * (before any encoding or decoding is done)
++     */
++    InitAnyANY_TEST();
++
++    decodedLen = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecAnyTestType (&buf, &att, &decodedLen, env);
++    }
++    else
++    {
++        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
++        exit (1);
++    }
++
++    fprintf (stderr, "decodedValue AnyTestType ::= ");
++    PrintAnyTestType (stderr, &att, 0);
++    fprintf (stderr, "\n\n");
++
++    /*
++     * setup a new buffer set up for writing.
++     * make sure size is big enough to hold the encoded
++     * value (may be larger than decoded value if encoding
++     * with indef lengths - so add 512 slush bytes)
++     */
++    encData = (char*) malloc (size + 512);
++    SBufInit (&encBuf, encData, size + 512);
++    SBufResetInWriteRvsMode (&encBuf);
++
++    encodedLen =  BEncAnyTestType (&encBuf, &att);
++    if ((encodedLen <= 0) || SBufWriteError (&encBuf))
++    {
++        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
++        exit (1);
++    }
++
++    /*
++     * free all of the decoded value since
++     * it has been encoded into the buffer.
++     * This is much more efficient than freeing
++     * each compontent of the value individually
++     */
++    ResetNibbleMem();
++
++    /*
++     * write encoded value from encBuf
++     * to stdout
++     */
++    fwrite (SBufDataPtr (&encBuf), SBufDataLen (&encBuf), 1, stdout);
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/any/genber.c snacc-1.3b4/c-examples/any/genber.c
+--- snacc-1.3bbn/c-examples/any/genber.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/any/genber.c	1995-07-24 20:40:50.000000000 +0000
+@@ -0,0 +1,164 @@
++/*
++ * c-examples/any/genber.c - builds an AnyTestType value and writes BER form
++ *            of the value to a file called "att.ber"
++ *
++ *  Shows how to build internal rep of lists and ANY values.
++ *
++ *  MS 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.5  1995/07/24 20:40:50  rj
++ * any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
++ *
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  15:17:36  rj
++ * cosmetic changes
++ *
++ * Revision 1.3  1994/08/31  23:48:06  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:32  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include <sys/types.h> /* this must be before stddef for gcc-2.3.1 */
++#include <stddef.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <sys/file.h>
++#include <sys/stat.h>
++#include <stdio.h>
++
++#include "asn-incl.h"
++#include "any.h"
++
++
++main (int argc, char *argv[])
++{
++    FILE *outputFile;
++    SBuf outputBuf;
++    unsigned long int encodedLen;
++    int dataSize = 1024;
++    int i;
++    char data[1024];
++    AnyTestType att;
++    TSeq1 ts1;
++    TSeq2 ts2;
++    AttrValue1 **atv1Hndl;
++    AttrValue2 **atv2Hndl;
++    AsnInt intVal;
++    AsnBool boolVal;
++    AsnOcts octsVal;
++    AsnBits bitsVal;
++    AsnReal realVal;
++
++    /* used to alloc part of value (Asn1Alloc & AsnListAppend) */
++    InitNibbleMem (512,512);
++
++    /* init id to type ANY hash table */
++    InitAnyANY_TEST();
++
++    att.intMap = AsnListNew (sizeof (void*));
++    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
++    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
++    (*atv1Hndl)->id = intId;  /* the id's are defined in the generated code */
++    intVal = -99;
++    (*atv1Hndl)->anyDefBy.value = (void*) &intVal;
++
++    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
++    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
++    (*atv1Hndl)->id = boolId;
++    boolVal = TRUE;
++    (*atv1Hndl)->anyDefBy.value = (void*)&boolVal;
++
++    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
++    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
++    (*atv1Hndl)->id = octsId;
++    octsVal.octs = "Hi Mom";
++    octsVal.octetLen = strlen (octsVal.octs);
++    (*atv1Hndl)->anyDefBy.value = (void*)&octsVal;
++
++    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
++    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
++    (*atv1Hndl)->id = bitsId;
++    bitsVal.bitLen = 10;
++    bitsVal.bits = (char*)&i;
++    SetAsnBit (&bitsVal, 0);
++    ClrAsnBit (&bitsVal, 1);
++    SetAsnBit (&bitsVal, 2);
++    ClrAsnBit (&bitsVal, 3);
++    SetAsnBit (&bitsVal, 4);
++    ClrAsnBit (&bitsVal, 5);
++    SetAsnBit (&bitsVal, 6);
++    ClrAsnBit (&bitsVal, 7);
++    SetAsnBit (&bitsVal, 8);
++    ClrAsnBit (&bitsVal, 9);
++    (*atv1Hndl)->anyDefBy.value = (void*)&bitsVal;
++
++    atv1Hndl = (AttrValue1**)AsnListAppend (att.intMap);
++    *atv1Hndl = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
++    (*atv1Hndl)->id = realId;
++    realVal = 108.3838;
++    (*atv1Hndl)->anyDefBy.value = (void*)&realVal;
++
++    /* now do TSeq2 with same vals but use OID as identifier */
++    att.oidMap = AsnListNew (sizeof (void*));
++
++    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
++    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
++    (*atv2Hndl)->id = intOid;
++    (*atv2Hndl)->anyDefBy.value = (void*)&intVal;
++
++    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
++    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
++    (*atv2Hndl)->id = boolOid;
++    (*atv2Hndl)->anyDefBy.value = (void*)&boolVal;
++
++    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
++    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
++    (*atv2Hndl)->id = octsOid;
++    (*atv2Hndl)->anyDefBy.value = (void*)&octsVal;
++
++    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
++    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
++    (*atv2Hndl)->id = bitsOid;
++    (*atv2Hndl)->anyDefBy.value = (void*)&bitsVal;
++
++    atv2Hndl = (AttrValue2**)AsnListAppend (att.oidMap);
++    *atv2Hndl = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
++    (*atv2Hndl)->id = realOid;
++    (*atv2Hndl)->anyDefBy.value = (void*)&realVal;
++
++    SBufInit (&outputBuf,data, dataSize);
++    SBufResetInWriteRvsMode (&outputBuf);
++
++    encodedLen = BEncAnyTestType (&outputBuf, &att);
++    if ((encodedLen <= 0) || (SBufWriteError (&outputBuf)))
++    {
++        fprintf (stderr, "failed encoding AnyTestType value\n");
++        exit (1);
++    }
++
++    outputFile = fopen ("att.ber", "w");
++    if (!outputFile)
++    {
++        perror ("fopen:");
++        exit (1);
++    }
++
++    SBufResetInReadMode (&outputBuf);
++    for ( ; encodedLen > 0; encodedLen--)
++        fputc (SBufGetByte (&outputBuf), outputFile);
++
++
++    printf ("Wrote the following BER AnyTestType value to att.ber.\n");
++    printf ("Test it with \"def\" and \"indef\"\n");
++
++    PrintAnyTestType (stdout, &att, 0);
++    printf ("\n");
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/any/makefile snacc-1.3b4/c-examples/any/makefile
+--- snacc-1.3bbn/c-examples/any/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/any/makefile	1995-07-24 20:42:31.000000000 +0000
+@@ -0,0 +1,144 @@
++# c-examples/any/makefile
++#
++# WARNING: this makefile isn't safe for parallel making!
++#
++#  compile the any example
++#
++# MS 92
++#
++# $Header$
++# $Log$
++# Revision 1.6  1995/07/24 20:42:31  rj
++# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
++# any-test.[hc] becomes any.[hc] due to to snacc's new file name generation scheme.
++#
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.5  1995/02/20  11:51:39  rj
++# build snacc if it doesn't exist.
++# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
++#
++# Revision 1.4  1995/02/13  15:05:05  rj
++# augment CPPFLAGS, not overwrite.
++# use $(@D) and $(@F) instead of `dirname $@` and `basename $@` (not every system's got the commands).
++# we need the compiler for the dependencies, so make it if it doesn't yet exist.
++#
++# Revision 1.3  1994/08/31  21:41:37  rj
++# rebuild the executables when the c-lib is newer.
++#
++# Revision 1.2  1994/08/31  10:31:49  rj
++# since .o files get moved, a few more dependencies are needed.
++#
++# Revision 1.1  1994/08/31  08:46:20  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SRC_DIR	= $(TOP)/asn1specs
++
++ASN1_C_LIB_DIR	= $(TOP)/c-lib
++ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
++ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
++SNACCFLAGS	= -u $(USEFUL_TYPES)
++
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF $(LENFLAG)
++
++ASN1FILES	= $(ASN1_SRC_DIR)/any.asn1
++
++# generated by snacc from any.asn1:
++ASN1HFILES	= any.h
++ASN1CFILES	= any.c
++
++CFILES = \
++	genber.c	\
++	example.c
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)
++
++#-------------------------------------------------------------------------------
++
++all::		genber def indef
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++def-obj		\
++indef-obj:
++		mkdir $@
++
++def-obj/any.o	\
++def-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++indef-obj/any.o	\
++indef-obj/example.o:
++		$(REASON)
++		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++genber:		def-obj/any.o genber.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ def-obj/any.o genber.o $(ASN1_C_LIB) $(LIBS)
++
++def: 		def-obj/any.o def-obj/example.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ def-obj/any.o def-obj/example.o $(ASN1_C_LIB) $(LIBS)
++
++indef:		indef-obj/any.o indef-obj/example.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ indef-obj/any.o indef-obj/example.o $(ASN1_C_LIB) $(LIBS)
++
++genber	\
++def	\
++indef:		$(ASN1_C_LIB)
++
++.PHONY:	check
++
++check::		genber def indef
++		$(RM) foo.ber bar.ber
++		./genber
++		./indef att.ber > foo.ber
++		./def foo.ber > bar.ber
++		@echo ''
++		@if cmp -s bar.ber att.ber; then\
++		  echo "+++ Passed simple encode/decode tests using any.asn1.";\
++		else\
++		  echo "--- Failed simple encode/decode tests using any.asn1.";\
++		fi
++		@echo ''
++		$(RM) foo.ber bar.ber
++
++clean::
++		$(RM) *.o *~ .emacs* core def indef genber att.ber $(ASN1HFILES) $(ASN1CFILES)
++		$(RM) -r def-obj indef-obj
++		$(RM) foo.ber bar.ber
++
++depend::	$(SNACC)
++
++include ../../maketail
++
++depend::
++		cp dependencies deps
++		for dir in def-obj indef-obj; do\
++		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
++		done
++		mv deps dependencies
+diff -uraN snacc-1.3bbn/c-examples/makefile snacc-1.3b4/c-examples/makefile
+--- snacc-1.3bbn/c-examples/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/makefile	1995-07-24 20:38:56.000000000 +0000
+@@ -0,0 +1,42 @@
++# c-examples/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.2  1995/07/24 20:38:56  rj
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++
++SUBDIRS		= test-lib simple any snmp
++
++#-------------------------------------------------------------------------------
++
++.PHONY:	implicit_default
++implicit_default::
++		$(MAKE) subdirs
++
++subdirs::	$(SUBDIRS)
++$(SUBDIRS)::
++		cd $@ && $(MAKE) $(subtarget)
++
++# the following hack is needed for older make versions (gmake doesn't need it):
++init-depend::
++		@for dir in $(SUBDIRS); do\
++		  test -f $$dir/dependencies || touch $$dir/dependencies;\
++		done
++
++.DEFAULT::
++		$(MAKE) subdirs subtarget=$@
++
++distfiles::
++		echo makefile
++		for dir in $(SUBDIRS); do\
++		  subfiles=`cd $$dir && $(MAKE) -s $@`;\
++		  for file in $$subfiles; do\
++		    echo "$$dir/$$file";\
++		  done;\
++		done
++
++# dummy:
++install::
+diff -uraN snacc-1.3bbn/c-examples/simple/README snacc-1.3b4/c-examples/simple/README
+--- snacc-1.3bbn/c-examples/simple/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/README	1995-02-17 16:17:24.000000000 +0000
+@@ -0,0 +1,128 @@
++(RCS control information is at the end of this file.)
++
++
++C Simple Example README
++-----------------------
++
++This directory should have 8 files in it:
++
++README       - this file
++genber.c     - C source code for a program that creates and encodes
++               a PersonnelRecord value to a file.
++expbuf_ex.c  - C source code for a program that calls the generated
++               PersonnelRecord encoder and decoder routines
++               using the ExpBuf buffer type
++minbuf_ex.c  - C source code for program that calls the generated
++               PersonnelRecord encoder and decoder routines
++               using the MinBuf buffer type
++sbuf_ex.c    - C source code for a program that calls the generated
++               PersonnelRecord encoder and decoder routines
++               using the MinBuf buffer type
++makefile     - compiles the example programs
++good_pr.ber  - BER encoding of a Personnel Record (all definite lengths)
++
++
++
++Type "make" to generate the 7 example programs:
++        genber
++        expbuf_def
++        expbuf_indef
++        minbuf_def
++        minbuf_indef
++        sbuf_def
++        sbuf_indef
++
++
++snacc is called from the makefile on snacc/asn1specs/p_rec.asn1 to
++generate the following files:
++
++p_rec.h  - C data structs for PersonnelRecord and prototypes for
++           the generated encode, decode, print and free routines.
++p_rec.c  - C source code for the PersonnelRecord encode, decode,
++           print, and free routines.
++
++These source files are then compiled with *_ex.c and genber.c files to
++make 7 programs.  Each program takes 1 argument (except genber), the
++name of a file containing an BER encoded PersonnelRecord value.
++
++
++Try the following: (or use the makefile's `check' phony target)
++
++eg% ./genber				# create a file called pr.ber
++eg% ./sbuf_indef good_pr.ber > indef_pr.ber
++eg% ./sbuf_def indef_pr.ber > def_pr.ber
++eg% diff good_pr.ber def_pr.ber		# should be no differences
++
++
++The above commands decode the BER value in "good_pr.ber" and
++indef_pr.ber respectively and then re-encode then to stdout.
++Both programs will decode any valid BER representation of a
++PersonnelRecord value but, the sbuf_def program will re-encode the
++given data using only the definite length BER format and the
++sbuf_indef program will re-encode the given data using only the
++indefinite length BER format.
++
++Compare the lengths of the def_pr.ber and indef_pr.ber files,
++indefinite length encodings are usually larger.
++
++
++
++Things to Note
++--------------
++
++
++Look at genber.c to see how to build a C value and then encode it.
++look at the *_ex.c files to see the different types of buffer
++manipulation.  Read the comments in the code.
++
++It should be relatively simple to change the memory and buffer
++management to fit your target environment.
++(see snacc/c_include/asn_config.h.)
++
++
++Snacc ASN.1 comment commands
++
++Notice the special "--snacc" ASN.1 comment in snacc/asn1specs/p_rec.asn1.
++
++PersonnelRecord ::= --snacc isPdu:"TRUE" -- [APPLICATION 0] IMPLICIT SET
++ { ... etc. ... }
++
++The "isPdu" flag tells snacc that the PersonnelRecord is a PDU type
++that you will be calling the encoding and decoding routines directly
++from your code.  This causes snacc to generate the
++"BEncPersonnelRecord" and "BDecPersonnelRecord" routines in addition
++to the standard "BEncPersonnelRecordContent" and
++"BDecPersonnelRecordContent".
++
++The Content encoding and decoding routines only deal with the content
++of the type, ignoring all of the tag and length pairs on the given
++type (in this case the APPLICATION (CONSTRUCTED) 0 tag and the length
++for the SET).  The "BEncPersonnelRecord" and "BDecPersonnelRecord"
++routines do encode the APPLICATION tag and the SET's length.  This
++design is motivated by IMPLICIT tagging.
++
++The compiler generated routines generally only call the content
++oriented routines except in the case of ANY and ANY DEFINED BY types.
++For ANY and ANY DEFINED BY types the PDU form of the rouine is called
++since the tags are not known by the containing type.
++
++
++Length formats
++
++Each pair of *_def and *_indef programs were generated from the same
++source file, *_ex.c.  Indefinite length encoders can be created by
++giving the -DUSE_INDEF_LEN flag to the C compiler when compiling.
++Currently the indefinite/definite length encoder choice is made a
++compile time.  To change this to a run-time decision, a simple
++solution would be to modify BerEncodeConsLen and BerEncodeEocIfNec
++macros in snacc/c_lib/asn_len.h to check a global flag.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1995/02/17 16:17:24  rj
++# reflect the test script's integration into the makefile.
++#
++# Revision 1.1  1994/08/31  08:46:22  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c-examples/simple/expbuf-ex.c snacc-1.3b4/c-examples/simple/expbuf-ex.c
+--- snacc-1.3bbn/c-examples/simple/expbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/expbuf-ex.c	1995-07-24 20:44:58.000000000 +0000
+@@ -0,0 +1,166 @@
++/*
++ * c_examples/simple/expbuf_ex.c - an example of how to call C ASN.1-BER
++ *              encoders and decoders generated by snacc
++ *              with the ExpBuf buffer.
++ *
++ * AUTHOR: Mike Sample
++ * DATE:   Mar 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.5  1995/07/24 20:44:58  rj
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  15:12:53  rj
++ * cosmetic changes
++ *
++ * Revision 1.3  1994/08/31  23:48:29  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:34  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include "asn-incl.h"
++
++#include <sys/file.h>
++#include <sys/stat.h>
++#if HAVE_FCNTL_H 
++#include <fcntl.h>
++#endif
++#include <stdio.h>
++
++#include "p-rec.h"
++
++
++main PARAMS ((argc, argv),
++    int argc _AND_
++    char *argv[])
++{
++    int fd;
++    ExpBuf *buf;
++    ExpBuf  b;
++    ExpBuf *tmpBuf;
++    AsnLen encodedLen;
++    AsnLen decodedLen;
++    int     val;
++    PersonnelRecord pr;
++    int      size;
++    char    *origData;
++    struct stat sbuf;
++    jmp_buf env;
++    int  decodeErr;
++    AsnTag tag;
++
++
++    if (argc != 2)
++    {
++        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
++        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
++        fprintf (stderr, "   and re-encodes it to stdout\n");
++        exit (1);
++    }
++
++    fd = open (argv[1], O_RDONLY, 0);
++    if (fd < 0)
++    {
++        perror ("main: fopen");
++        exit (1);
++    }
++
++    if (fstat (fd, &sbuf) < 0)
++    {
++        perror ("main: fstat");
++        exit (1);
++    }
++
++    size = sbuf.st_size;
++    origData = (char*)malloc (size);
++    if (read (fd, origData, size) != size)
++    {
++        perror ("main: read");
++        exit (1);
++    }
++
++    close (fd);
++
++    /*
++     * the "1024" is the size in bytes of the data
++     * blk to allocate when writing to a buffer that
++     * fills up.
++     */
++    ExpBufInit (1024);
++
++    /*
++     * the first argument (512) is the number of bytes to
++     * initially allocate for the decoder to allocate from.
++     * The second argument (512) is the size in bytes to
++     * enlarge the nibble memory by when it fills up
++     */
++    InitNibbleMem (512, 512);
++
++    /*
++     * put the BER data read from the file
++     * into buffer format, ready for reading from the
++     * beginning
++     */
++    buf = &b;
++    ExpBufInstallDataInBuf (buf, origData, size);
++
++    decodedLen = 0;
++    decodeErr = FALSE;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
++    }
++    else
++    {
++        decodeErr = TRUE;
++        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
++    }
++
++    if (decodeErr)
++        exit (1);
++
++    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
++    PrintPersonnelRecord (stderr, &pr, 0);
++    fprintf (stderr, "\n\n");
++
++    /*
++     * allocate a new buffer set up for writing to
++     */
++    buf = ExpBufAllocBufAndData();
++
++    encodedLen =  BEncPersonnelRecord (&buf, &pr);
++
++    /*
++     * Alway check for a buffer write error after encoding
++     */
++    if (ExpBufWriteError (&buf))
++    {
++        fprintf (stderr, "ERROR - buffer write error during encoding\n");
++        exit (1);
++    }
++
++
++    /*
++     * free all of the decoded value since
++     * it has been encoded into the buffer.
++     * This is much more efficient than freeing
++     * each compontent of the value individually
++     */
++    ResetNibbleMem();
++
++    /*
++     * go through buffer (s) and write encoded value
++     * to stdout
++     */
++    buf->curr = buf->dataStart;
++    for ( tmpBuf = buf; tmpBuf != NULL; tmpBuf = tmpBuf->next)
++    {
++        fwrite (tmpBuf->dataStart, tmpBuf->dataEnd - tmpBuf->dataStart, 1, stdout);
++    }
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/simple/genber.c snacc-1.3b4/c-examples/simple/genber.c
+--- snacc-1.3bbn/c-examples/simple/genber.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/genber.c	1995-07-24 20:45:00.000000000 +0000
+@@ -0,0 +1,154 @@
++/*
++ * c_examples/simple/genber.c - builds a PersonnelRecord value and writes BER form
++ *            of the value to a file called "pr.ber"
++ *
++ *
++ *  MS 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.6  1995/07/24 20:45:00  rj
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.5  1995/02/18  15:12:54  rj
++ * cosmetic changes
++ *
++ * Revision 1.4  1995/02/17  16:21:03  rj
++ * unnecessary inclusion of <sys/stdtypes.h> removed.
++ *
++ * Revision 1.3  1994/09/01  01:02:37  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:35  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include "asn-incl.h"
++
++#include <sys/file.h>
++#include <sys/stat.h>
++
++#include <stddef.h>
++#if STDC_HEADERS
++#include <stdlib.h>
++#endif
++#include <errno.h>
++#include <stdio.h>
++
++#include "p-rec.h"
++
++
++main (int argc, char *argv[])
++{
++    FILE *outputFile;
++    SBuf outputBuf;
++    unsigned long int encodedLen;
++    int dataSize = 1024;
++    int i;
++    char data[1024];
++    PersonnelRecord pr;
++    ChildInformation **childHndl;
++
++    /* used to alloc part of value (Asn1Alloc & AsnListAppend) */
++    InitNibbleMem (512,512);
++
++    pr.name = Asn1Alloc (sizeof (Name));
++    pr.name->givenName.octs = "John";
++    pr.name->givenName.octetLen = strlen (pr.name->givenName.octs);
++    pr.name->initial.octs = "E";
++    pr.name->initial.octetLen = strlen (pr.name->initial.octs);
++    pr.name->familyName.octs = "Smith";
++    pr.name->familyName.octetLen = strlen (pr.name->familyName.octs);
++
++    pr.title.octs = "The Big Cheese";
++    pr.title.octetLen = strlen (pr.title.octs);
++
++    pr.employeeNumber = 99999;
++
++    pr.dateOfHire.octs = "19820104";
++    pr.dateOfHire.octetLen = strlen (pr.dateOfHire.octs);
++
++    pr.nameOfSpouse = (Name*) Asn1Alloc (sizeof (Name));
++    pr.nameOfSpouse->givenName.octs = "Mary";
++    pr.nameOfSpouse->givenName.octetLen =
++        strlen (pr.nameOfSpouse->givenName.octs);
++    pr.nameOfSpouse->initial.octs = "L";
++    pr.nameOfSpouse->initial.octetLen = strlen (pr.nameOfSpouse->initial.octs);
++    pr.nameOfSpouse->familyName.octs = "Smith";
++    pr.nameOfSpouse->familyName.octetLen =
++        strlen (pr.nameOfSpouse->familyName.octs);
++
++    pr.children = AsnListNew (sizeof (void*));
++
++    childHndl = AsnListAppend (pr.children);
++    *childHndl = Asn1Alloc (sizeof (ChildInformation));
++
++    (*childHndl)->dateOfBirth.octs = "19570310";
++    (*childHndl)->dateOfBirth.octetLen  = strlen ((*childHndl)->dateOfBirth.octs);
++    (*childHndl)->name = (Name*) Asn1Alloc (sizeof (Name));
++
++    (*childHndl)->name->givenName.octs = "James";
++    (*childHndl)->name->givenName.octetLen =
++        strlen ((*childHndl)->name->givenName.octs);
++    (*childHndl)->name->initial.octs = "R";
++    (*childHndl)->name->initial.octetLen =
++        strlen ((*childHndl)->name->initial.octs);
++    (*childHndl)->name->familyName.octs = "Smith";
++    (*childHndl)->name->familyName.octetLen =
++        strlen ((*childHndl)->name->familyName.octs);
++
++    childHndl = AsnListAppend (pr.children);
++    *childHndl = Asn1Alloc (sizeof (ChildInformation));
++
++    (*childHndl)->dateOfBirth.octs = "19610621";
++    (*childHndl)->dateOfBirth.octetLen  = strlen ((*childHndl)->dateOfBirth.octs);
++
++    (*childHndl)->name = (Name*) Asn1Alloc (sizeof (Name));
++
++    (*childHndl)->name->givenName.octs = "Lisa";
++    (*childHndl)->name->givenName.octetLen =
++        strlen ((*childHndl)->name->givenName.octs);
++    (*childHndl)->name->initial.octs = "M";
++    (*childHndl)->name->initial.octetLen =
++        strlen ((*childHndl)->name->initial.octs);
++    (*childHndl)->name->familyName.octs = "Smith";
++    (*childHndl)->name->familyName.octetLen =
++        strlen ((*childHndl)->name->familyName.octs);
++
++    SBufInit (&outputBuf,data, dataSize);
++    SBufResetInWriteRvsMode (&outputBuf);
++
++    encodedLen = BEncPersonnelRecord (&outputBuf, &pr);
++
++    /*
++     * after encoding a value ALWAYS check for write error
++     * in the buffer.  The encode routine do not use longjmp
++     * when they enter an error state
++     */
++    if ((encodedLen <= 0) || (SBufWriteError (&outputBuf)))
++    {
++        fprintf (stderr, "failed encoding PersonnelRecord value\n");
++        exit (1);
++    }
++
++    outputFile = fopen ("pr.ber", "w");
++    if (!outputFile)
++    {
++        perror ("fopen:");
++        exit (1);
++    }
++
++    SBufResetInReadMode (&outputBuf);
++    for ( ; encodedLen > 0; encodedLen--)
++        fputc (SBufGetByte (&outputBuf), outputFile);
++
++
++    printf ("Wrote the following BER PersonnelRecord value to pr.ber.\n");
++    printf ("Test it with \"def\" and \"indef\"\n");
++
++    PrintPersonnelRecord (stdout, &pr, 0);
++    printf ("\n");
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/simple/good-pr.ber.uu snacc-1.3b4/c-examples/simple/good-pr.ber.uu
+--- snacc-1.3bbn/c-examples/simple/good-pr.ber.uu	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/good-pr.ber.uu	2005-07-30 16:56:21.235084304 +0000
+@@ -0,0 +1,7 @@
++begin 644 good-pr.ber
++M8(&,81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E0@,!AI^A
++M"D,(,3DX,C`Q,#2B$F$0%@1-87)Y%@%,%@53;6ET:*-!,1]A$18%2F%M97,6
++M`5(6!5-M:71HH`I#"#$Y-3<P,S$P,1YA$!8$3&ES818!318%4VUI=&B@"D,(
++(,3DV,3`V,C$`
++`
++end
+diff -uraN snacc-1.3bbn/c-examples/simple/makefile snacc-1.3b4/c-examples/simple/makefile
+--- snacc-1.3bbn/c-examples/simple/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/makefile	1995-07-24 20:46:17.000000000 +0000
+@@ -0,0 +1,198 @@
++# file: c-examples/simple/makefile
++#
++# WARNING: this makefile isn't safe for parallel making!
++#
++# $Header$
++# $Log$
++# Revision 1.6  1995/07/24 20:46:17  rj
++# useful.asn1 renamed to asn-useful.asn1 to accomodate to snacc's new file name generation scheme.
++#
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.5  1995/02/20  11:50:49  rj
++# build snacc if it doesn't exist.
++# some makes leave a trailing slash on $(@D), others don't. this causes some mkdir(1)s to deny their cooperation. therefore, the slash has got to be stripped.
++#
++# Revision 1.4  1995/02/13  15:05:36  rj
++# augment CPPFLAGS, not overwrite.
++# use $(@D) and $(@F) instead of `dirname $@` and `basename $@` (not every system's got the commands).
++# we need the compiler for the dependencies, so make it if it doesn't yet exist.
++#
++# Revision 1.3  1994/08/31  21:42:52  rj
++# rebuild the executables when the c-lib they get linked against is newer.
++# the file good-pr.ber needs to be distributed.
++#
++# Revision 1.2  1994/08/31  10:31:52  rj
++# since .o files get moved, a few more dependencies are needed.
++#
++# Revision 1.1  1994/08/31  08:46:27  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SRC_DIR	= $(TOP)/asn1specs
++
++ASN1_C_LIB_DIR	= $(TOP)/c-lib
++ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
++MBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1cmbuf.a
++SBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
++EBUF_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1cebuf.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
++SNACCFLAGS	= -u $(USEFUL_TYPES)
++
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) $(BUFFLAG) $(LENFLAG)
++
++ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
++# generated by snacc from p-rec.asn1:
++ASN1HFILES	= p-rec.h
++ASN1CFILES	= p-rec.c
++
++CFILES = \
++	genber.c	\
++	minbuf-ex.c	\
++	expbuf-ex.c	\
++	sbuf-ex.c
++
++BUFFLAG		= -DUSE_SBUF
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)	\
++	good-pr.ber
++
++#-------------------------------------------------------------------------------
++
++all::		genber minbuf-def minbuf-indef expbuf-def expbuf-indef sbuf-def sbuf-indef
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) $(SNACCFLAGS) $(ASN1FILES)
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++min-def-obj	\
++min-indef-obj	\
++exp-def-obj	\
++exp-indef-obj	\
++s-def-obj	\
++s-indef-obj:
++		mkdir $@
++
++min-def-obj/p-rec.o	\
++min-def-obj/minbuf-ex.o:
++		$(REASON)
++		$(MAKE) BUFFLAG=-DUSE_MIN_BUF LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++min-indef-obj/p-rec.o	\
++min-indef-obj/minbuf-ex.o:
++		$(REASON)
++		$(MAKE) BUFFLAG=-DUSE_MIN_BUF LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++exp-def-obj/p-rec.o	\
++exp-def-obj/expbuf-ex.o:
++		$(REASON)
++		$(MAKE) BUFFLAG=-DUSE_EXP_BUF LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++exp-indef-obj/p-rec.o	\
++exp-indef-obj/expbuf-ex.o:
++		$(REASON)
++		$(MAKE) BUFFLAG=-DUSE_EXP_BUF LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++s-def-obj/p-rec.o	\
++s-def-obj/sbuf-ex.o:
++		$(REASON)
++		$(MAKE) LENFLAG= `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++s-indef-obj/p-rec.o	\
++s-indef-obj/sbuf-ex.o:
++		$(REASON)
++		$(MAKE) LENFLAG=-DUSE_INDEF_LEN `echo $(@D) | sed -e 's:/$$::'` $(@F)
++		mv $(@F) $@
++
++genber:		s-def-obj/p-rec.o genber.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ s-def-obj/p-rec.o genber.o $(SBUF_ASN1_LIB) $(LIBS)
++
++minbuf-def: 	min-def-obj/p-rec.o min-def-obj/minbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ min-def-obj/p-rec.o min-def-obj/minbuf-ex.o $(MBUF_ASN1_LIB) $(LIBS)
++
++minbuf-indef:	min-indef-obj/p-rec.o min-indef-obj/minbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ min-indef-obj/p-rec.o min-indef-obj/minbuf-ex.o $(MBUF_ASN1_LIB) $(LIBS)
++
++expbuf-def: 	exp-def-obj/p-rec.o exp-def-obj/expbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ exp-def-obj/p-rec.o exp-def-obj/expbuf-ex.o $(EBUF_ASN1_LIB) $(LIBS)
++
++expbuf-indef:	exp-indef-obj/p-rec.o exp-indef-obj/expbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ exp-indef-obj/p-rec.o exp-indef-obj/expbuf-ex.o $(EBUF_ASN1_LIB) $(LIBS)
++
++sbuf-def: 	s-def-obj/p-rec.o s-def-obj/sbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ s-def-obj/p-rec.o s-def-obj/sbuf-ex.o $(SBUF_ASN1_LIB) $(LIBS)
++
++sbuf-indef:	s-indef-obj/p-rec.o s-indef-obj/sbuf-ex.o
++		$(REASON)
++		$(CC) $(LDFLAGS) -o $@ s-indef-obj/p-rec.o s-indef-obj/sbuf-ex.o $(SBUF_ASN1_LIB) $(LIBS)
++
++genber		\
++sbuf-def	\
++sbuf-indef:	$(SBUF_ASN1_LIB)
++
++minbuf-def	\
++minbuf-indef:	$(MINBUF_ASN1_LIB)
++
++expbuf-def	\
++expbuf-indef:	$(EXPBUF_ASN1_LIB)
++
++.PHONY:	check
++
++check::		minbuf-def minbuf-indef expbuf-def expbuf-indef sbuf-def sbuf-indef
++		for bt in min exp s; do\
++		  $(RM) $$bt-foo.ber $$bt-bar.ber;\
++		  ./$${bt}buf-indef good-pr.ber > $$bt-foo.ber;\
++		  ./$${bt}buf-def $$bt-foo.ber > $$bt-bar.ber;\
++		done
++		@for bt in min exp s; do\
++		  if cmp -s $$bt-bar.ber good-pr.ber; then\
++		    echo "+++ Passed simple encode/decode tests using p-rec.asn1 with $${bt}bufs.";\
++		  else\
++		    echo "--- Failed simple encode/decode tests using p-rec.asn1 with $${bt}bufs.";\
++		  fi;\
++		  $(RM) $$bt-foo.ber $$bt-bar.ber;\
++		done
++
++clean::
++		$(RM) *.o *~ core .emacs*
++		$(RM) expbuf-def expbuf-indef sbuf-indef sbuf-def minbuf-def minbuf-indef genber pr.ber $(ASN1HFILES) $(ASN1CFILES)
++		$(RM) -r *-def-obj *-indef-obj
++		$(RM) *-foo.ber *-bar.ber
++
++depend::	$(SNACC)
++
++include ../../maketail
++
++depend::
++		cp dependencies deps
++		for dir in min-def-obj min-indef-obj exp-def-obj exp-indef-obj s-def-obj s-indef-obj; do\
++		  < dependencies sed -e 's:^\(.*\.o\):'"$$dir"'/\1:' >> deps;\
++		done
++		mv deps dependencies
+diff -uraN snacc-1.3bbn/c-examples/simple/minbuf-ex.c snacc-1.3b4/c-examples/simple/minbuf-ex.c
+--- snacc-1.3bbn/c-examples/simple/minbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/minbuf-ex.c	1995-07-24 20:46:59.000000000 +0000
+@@ -0,0 +1,162 @@
++/*
++ * c_examples/simple/minbuf_ex.c - an example of how to call C ASN.1-BER
++ *               encoders and decoders generated by snacc
++ *               using the MinBuf buffer.
++ *
++ * AUTHOR: Mike Sample
++ * DATE:   Mar 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.5  1995/07/24 20:46:59  rj
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  15:12:55  rj
++ * cosmetic changes
++ *
++ * Revision 1.3  1994/09/01  01:02:38  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:36  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include "asn-incl.h"
++
++#include <sys/file.h>
++#include <sys/stat.h>
++#if HAVE_FCNTL_H 
++#include <fcntl.h>
++#endif
++#include <stdio.h>
++
++#include "p-rec.h"
++
++
++main PARAMS ((argc, argv),
++    int argc _AND_
++    char *argv[])
++{
++    int fd;
++    char  *buf;
++    char *encBuf;
++    char *encData;
++    int encBufSize;
++    AsnLen encodedLen;
++    AsnLen decodedLen;
++    int     val;
++    PersonnelRecord pr;
++    int      size;
++    char    *origData;
++    struct stat sbuf;
++    jmp_buf env;
++    int  decodeErr;
++    AsnTag tag;
++
++
++    if (argc != 2)
++    {
++        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
++        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
++        fprintf (stderr, "   and re-encodes it to stdout\n");
++        exit (1);
++    }
++
++    fd = open (argv[1], O_RDONLY, 0);
++    if (fd < 0)
++    {
++        perror ("main: fopen");
++        exit (1);
++    }
++
++    if (fstat (fd, &sbuf) < 0)
++    {
++        perror ("main: fstat");
++        exit (1);
++    }
++
++    size = sbuf.st_size;
++    origData = (char*)malloc (size);
++    if (read (fd, origData, size) != size)
++    {
++        perror ("main: read");
++        exit (1);
++    }
++
++    close (fd);
++
++    /* set up min buf  */
++    buf = origData;
++
++    /*
++     * the first argument (512) is the number of bytes to
++     * initially allocate for the decoder to allocate from.
++     * The second argument (512) is the size in bytes to
++     * enlarge the nibble memory by when it fills up
++     */
++    InitNibbleMem (512, 512);
++
++
++    decodedLen = 0;
++    decodeErr = FALSE;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
++    }
++    else
++    {
++        decodeErr = TRUE;
++        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
++    }
++
++    if (decodeErr)
++        exit (1);
++
++    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
++    PrintPersonnelRecord (stderr, &pr, 0);
++    fprintf (stderr, "\n\n");
++
++    /*
++     * setup a new buffer set up for writing.
++     * make sure size is big enough to hold the encoded
++     * value (may be larger than decoded value if encoding
++     * with indef lengths - so add 512 slush bytes)
++     */
++    encBufSize = size + 512;
++    encData = (char*) malloc (encBufSize);
++
++    /*
++     * set 'buffer' up for writing by setting ptr
++     * byte after last byte of the block
++     */
++    encBuf = encData + encBufSize;
++    encodedLen =  BEncPersonnelRecord (&encBuf, &pr);
++
++    /*
++     *  this will never report a write error
++     *  since no error checking done by MinBuf code
++     *  and alawys return false for when read or write errors.
++     */
++    if (MinBufWriteError (&encBuf))
++    {
++        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
++        exit (1);
++    }
++
++    /*
++     * free all of the decoded value since
++     * it has been encoded into the buffer.
++     * This is much more efficient than freeing
++     * each compontent of the value individually
++     */
++    ResetNibbleMem();
++
++    /*
++     * write encoded value from encBuf
++     * to stdout
++     */
++    fwrite (encBuf, encData + encBufSize - encBuf, 1, stdout);
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/simple/sbuf-ex.c snacc-1.3b4/c-examples/simple/sbuf-ex.c
+--- snacc-1.3bbn/c-examples/simple/sbuf-ex.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/simple/sbuf-ex.c	1995-07-24 20:47:00.000000000 +0000
+@@ -0,0 +1,154 @@
++/*
++ * c_examples/simple/sbuf_ex.c - an example of how to call C ASN.1-BER
++ *             encoders and decoders generated by snacc
++ *             using the SBuf buffer.
++ *
++ * AUTHOR: Mike Sample
++ * DATE:   Mar 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.5  1995/07/24 20:47:00  rj
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  15:12:56  rj
++ * cosmetic changes
++ *
++ * Revision 1.3  1994/09/01  01:02:39  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:37  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include "asn-incl.h"
++
++#include <sys/types.h>
++#include <sys/stat.h>
++#if HAVE_FCNTL_H 
++#include <fcntl.h>
++#endif
++#include <stdio.h>
++
++#include "p-rec.h"
++
++main PARAMS ((argc, argv),
++    int argc _AND_
++    char *argv[])
++{
++    int fd;
++    SBuf  buf;
++    SBuf  encBuf;
++    char *encData;
++    AsnLen encodedLen;
++    AsnLen decodedLen;
++    int     val;
++    PersonnelRecord pr;
++    int      size;
++    char    *origData;
++    struct stat sbuf;
++    jmp_buf env;
++    int  decodeErr;
++    AsnTag tag;
++
++    if (argc != 2)
++    {
++        fprintf (stderr, "Usage: %s <BER data file name>\n", argv[0]);
++        fprintf (stderr, "   Decodes the given PersonnelRecord BER data file\n");
++        fprintf (stderr, "   and re-encodes it to stdout\n");
++        exit (1);
++    }
++
++    fd = open (argv[1], O_RDONLY, 0);
++    if (fd < 0)
++    {
++        perror ("main: fopen");
++        exit (1);
++    }
++
++    if (fstat (fd, &sbuf) < 0)
++    {
++        perror ("main: fstat");
++        exit (1);
++    }
++
++    size = sbuf.st_size;
++    origData = (char*)malloc (size);
++    if (read (fd, origData, size) != size)
++    {
++        perror ("main: read");
++        exit (1);
++    }
++
++    close (fd);
++
++    /*
++     * puts the given data 'origData' of 'size' bytes
++     * into an SBuf and sets the SBuf up for reading
++     * origData from the beginning
++     */
++    SBufInstallData (&buf, origData, size);
++
++    /*
++     * the first argument (512) is the number of bytes to
++     * initially allocate for the decoder to allocate from.
++     * The second argument (512) is the size in bytes to
++     * enlarge the nibble memory by when it fills up
++     */
++    InitNibbleMem (512, 512);
++
++
++    decodedLen = 0;
++    decodeErr = FALSE;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecPersonnelRecord (&buf, &pr, &decodedLen, env);
++    }
++    else
++    {
++        decodeErr = TRUE;
++        fprintf (stderr, "ERROR - Decode routines returned %d\n",val);
++    }
++
++    if (decodeErr)
++        exit (1);
++
++    fprintf (stderr, "decodedValue PersonnelRecord ::= ");
++    PrintPersonnelRecord (stderr, &pr, 0);
++    fprintf (stderr, "\n\n");
++
++    /*
++     * setup a new buffer set up for writing.
++     * make sure size is big enough to hold the encoded
++     * value (may be larger than decoded value if encoding
++     * with indef lengths - so add 512 slush bytes)
++     */
++    encData = (char*) malloc (size + 512);
++    SBufInit (&encBuf, encData, size + 512);
++    SBufResetInWriteRvsMode (&encBuf);
++
++    encodedLen =  BEncPersonnelRecord (&encBuf, &pr);
++
++    if (SBufWriteError (&encBuf))
++    {
++        fprintf (stderr, "ERROR - buffer to hold the encoded value was too small\n");
++        exit (1);
++    }
++
++    /*
++     * free all of the decoded value since
++     * it has been encoded into the buffer.
++     * This is much more efficient than freeing
++     * each compontent of the value individually
++     */
++    ResetNibbleMem();
++
++    /*
++     * write encoded value from encBuf
++     * to stdout
++     */
++    fwrite (SBufDataPtr (&encBuf), SBufDataLen (&encBuf), 1, stdout);
++
++    return 0;
++}
+diff -uraN snacc-1.3bbn/c-examples/snmp/README snacc-1.3b4/c-examples/snmp/README
+--- snacc-1.3bbn/c-examples/snmp/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/snmp/README	1995-07-27 09:58:31.000000000 +0000
+@@ -0,0 +1,118 @@
++(RCS control information is at the end of this file.)
++
++
++C SNMP Example - Mike Sample Mar 92
++-----------------------------------
++
++This example illustrates a few more features of the compiler than the
++simple example.  It also shows some deficiencies.  No executable
++programs are generated by the makefile, it only generates the snmp
++code and compiles it without linking.
++
++This directory contains 2 files:
++        README
++        makefile
++
++Snacc generates source from the following ASN.1 files:
++        snacc/asn1specs/rfc1155_smi.asn1
++        snacc/asn1specs/rfc1157_snmp.asn1
++        snacc/asn1specs/rfc1213_mib2.asn1
++
++multi-module compilation
++   The IMPORT/EXPORT mechanisms of ASN.1 '88 are supported so you don't
++   have to dump all of the ASN.1 definitions into a single file
++   The order of the ASN.1 file arguments is the order that they
++   are included in the generated source files.  For example:
++
++   %1 snacc rfc1155-smi.asn1 rfc1157-snmp.asn1 rfc1213-mib2.asn1
++
++   causes the order in which hdr files are included  in rfc1213-mib.c
++   to be:
++
++   #include "asn-incl.h"
++   #include "rfc1155-smi.h"
++   #include "rfc1157-snmp.h"
++   #include "rfc1213-mib2.h"
++
++
++    Currently, snacc assumes that each ASN.1 file given on the command
++    line depends on all of the others on the command line.  There is
++    no attempt to compute the dependencies via the import lists alone.
++
++SNMP OBJECT-TYPE macro parsing / ANY type hash table
++   The SNMP OBJECT-TYPE macro is parsed.   This results in the
++   type in the "SYNTAX" part of the macro is put into
++   the ANY type hash table using the  OBJECT-TYPE macro's value as the
++   hash key.  Also if the type in the SYNTAX field is not defined
++   outsided of the macro (could be different tagging etc), a proper
++   type definition is generated for it.  If you want to change the way
++   the macro is handled, modify the corresponding routine in "do_macros.c".
++
++value definitions
++   The OBJECT IDENTIFIER values are turned into statically initialized
++   C values and included in the generated source and include file.  This
++   is also done for INTEGER and BOOLEAN values.  More complex values
++   are ignored by the compiler at the moment. (modify parse_vals.c if
++   you want to improve this)
++
++
++-P option of snacc is demonstrated
++   The ASN.1 for the parsed modules is generated from the internal data
++   structure.  This can be useful for making sure the compiler is
++   handling your ASN.1 files correctly.  It is also useful to see how
++   the types are modified and sorted to simplify code generation.
++   (see the snacc.output file after typeing "make")
++
++Deficiencies
++   A deficiency in parsing large integers is shown when parsing the
++   following rfc 1155 types:
++
++                  Counter ::=
++                      [APPLICATION 1]
++                          IMPLICIT INTEGER (0..4294967295)
++
++                  Gauge ::=
++                      [APPLICATION 2]
++                          IMPLICIT INTEGER (0..4294967295)
++
++                  TimeTicks ::=
++                      [APPLICATION 3]
++                          IMPLICIT INTEGER (0..4294967295)
++
++Due the size of a C long int the above ASN.1 is represented internally as:
++
++Counter ::= [APPLICATION 1] IMPLICIT INTEGER (0..-1)
++
++Gauge ::= [APPLICATION 2] IMPLICIT INTEGER (0..-1)
++
++TimeTicks ::= [APPLICATION 3] IMPLICIT INTEGER (0..-1)
++
++The ASN.1 library contains routines for encoding/decoding unsigned
++long integers but you must hand code the cases where it is used - the
++compiler never generates code that calls them.
++
++Note also that the produced code for the SNMP ASN.1 must be modified
++to correclty handle the "Opaque" data type.  SNMP does not use the ANY
++DEFINED BY type in an effort to simplify things.  Instead an OCTET
++STRING is used to hold and encoded value whose type is defined by an
++OBJECT IDENTIFIER.  With some simple modifications you can use the
++snacc AsnAnyDefinedBy type instead of the OCTET STRING to achieve
++the desired results.
++
++This should underline the danger of blindly trusting the compiler to
++do the right thing for protocols such as SNMP or X.500 where the type
++of an encoded value depends on a mechanism outside of ASN.1 or the ANY
++type (ANY DEFINED BY types should work automatically).
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.3  1995/07/27 09:58:31  rj
++# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
++#
++# Revision 1.2  1995/07/24  20:47:39  rj
++# changed `_' to `-' in file names.
++#
++# Revision 1.1  1994/08/31  08:46:33  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c-examples/snmp/makefile snacc-1.3b4/c-examples/snmp/makefile
+--- snacc-1.3bbn/c-examples/snmp/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/snmp/makefile	1995-07-27 09:57:38.000000000 +0000
+@@ -0,0 +1,91 @@
++# c-examples/snmp/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.6  1995/07/27 09:57:38  rj
++# rfc1155-smi.asn1, rfc1157-snmp.asn1 and rfc1213-mib2.asn1 renamed from 1155-smi.asn1, 1157-snmp.asn1 and 1213-mib2.asn1 to accomodate to snacc's new file name generation scheme.
++#
++# Revision 1.5  1995/07/24  20:48:27  rj
++# `cd && make' instead of `cd; make'.
++#
++# changed `_' to `-' in file names.
++#
++# Revision 1.4  1995/02/20  11:52:11  rj
++# build snacc if it doesn't exist.
++#
++# Revision 1.3  1995/02/13  15:05:48  rj
++# augment CPPFLAGS, not overwrite.
++# we need the compiler for the dependencies, so make it if it doesn't yet exist.
++#
++# Revision 1.2  1994/08/31  23:25:46  rj
++# print a less irritating usage.
++#
++# Revision 1.1  1994/08/31  08:46:34  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_SPEC_DIR	= $(TOP)/asn1specs
++
++ASN1_C_LIB_DIR	= $(TOP)/c-lib
++ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
++ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF
++
++ASN1FILES = \
++	$(ASN1_SPEC_DIR)/rfc1155-smi.asn1	\
++	$(ASN1_SPEC_DIR)/rfc1157-snmp.asn1	\
++	$(ASN1_SPEC_DIR)/rfc1213-mib2.asn1
++
++ASN1HFILES = \
++	rfc1155-smi.h	\
++	rfc1213-mib2.h	\
++	rfc1157-snmp.h
++
++ASN1CFILES = \
++	rfc1155-smi.c	\
++	rfc1213-mib2.c	\
++	rfc1157-snmp.c
++
++DISTFILES = \
++	README		\
++	makefile	\
++
++#-------------------------------------------------------------------------------
++
++default::	warning
++
++warning::
++		@echo ''
++		@echo 'read the README and enter `$(MAKE) fail` to test for yourself'
++		@echo ''
++
++fail::		$(ASN1HFILES) $(ASN1CFILES)
++		$(CC) $(CPPFLAGS) $(CFLAGS) -c $(ASN1CFILES)
++
++$(ASN1HFILES)	\
++$(ASN1CFILES):	$(SNACC) $(ASN1FILES)
++		$(REASON)
++		$(SNACC) -P $(ASN1FILES) > snacc.output~
++		mv snacc.output~ snacc.output
++
++$(SNACC):
++		cd $(@D) && $(MAKE) $(@F)
++
++check::
++		@echo "the purpose of this directories' contents is to show deficiencies."
++		@echo "if you want to exercise 'em, make the phony target "'`'"fail'"
++
++clean::
++		$(RM) *.o *~ .emacs* core $(ASN1HFILES) $(ASN1CFILES) snacc.output
++
++depend::	$(SNACC)
++
++include ../../maketail
+diff -uraN snacc-1.3bbn/c-examples/test-lib/README snacc-1.3b4/c-examples/test-lib/README
+--- snacc-1.3bbn/c-examples/test-lib/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/test-lib/README	1997-02-16 20:26:19.000000000 +0000
+@@ -0,0 +1,37 @@
++(RCS control information is at the end of this file.)
++
++
++C test_lib README
++-----------------
++
++This directory should have 3 files:
++        README - this file
++        makefile
++        test_lib.c
++
++Type "make" to compile test_lib.
++
++test_lib tests each encode and decode routine in the C ASN.1
++runtime library. Errors will be reported.
++
++test_lib should be run for each machine architecture you install snacc on.
++If you modify the library routines you should run test_lib again.
++
++The general testing methodology is:
++        1. test the buffer routines
++        2. test tags
++        3. test lengths
++        4. test each libarary type.
++
++For each type, a range of values is encoded and then decoded
++and and compared with the original value.
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.2  1997/02/16 20:26:19  rj
++# check-in of a few cosmetic changes
++#
++# Revision 1.1  1994/08/31  08:46:36  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
+diff -uraN snacc-1.3bbn/c-examples/test-lib/makefile snacc-1.3b4/c-examples/test-lib/makefile
+--- snacc-1.3bbn/c-examples/test-lib/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/test-lib/makefile	1995-07-24 20:50:11.000000000 +0000
+@@ -0,0 +1,50 @@
++# c-examples/test-lib/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.4  1995/07/24 20:50:11  rj
++# changed `_' to `-' in file names.
++#
++# Revision 1.3  1995/02/13  15:05:59  rj
++# augment CPPFLAGS, not overwrite.
++#
++# Revision 1.2  1994/08/31  21:43:20  rj
++# rebuild the executables when the c-lib is newer.
++#
++# Revision 1.1  1994/08/31  08:46:37  rj
++# first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++#
++
++include ../../makehead
++
++TOP		= ../..
++
++ASN1_C_LIB_DIR	= $(TOP)/c-lib
++ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
++ASN1_C_LIB	= $(ASN1_C_LIB_DIR)/libasn1csbuf.a
++
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_SBUF
++
++LDLIBS		= $(ASN1_C_LIB) $(LIBS)
++
++CFILES = \
++	test-lib.c
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)
++
++#-------------------------------------------------------------------------------
++
++default::	check
++
++check::		test-lib
++		./test-lib
++
++test-lib:	$(ASN1_C_LIB)
++
++clean::
++		$(RM) *.o *~ .emacs* test-lib core
++
++include ../../maketail
+diff -uraN snacc-1.3bbn/c-examples/test-lib/test-lib.c snacc-1.3b4/c-examples/test-lib/test-lib.c
+--- snacc-1.3bbn/c-examples/test-lib/test-lib.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/c-examples/test-lib/test-lib.c	1995-07-24 20:50:34.000000000 +0000
+@@ -0,0 +1,935 @@
++/*
++ * c_examples/test_lib/test_lib.c
++ *
++ * uses SBufs for buffers
++ *
++ * MS 92
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.5  1995/07/24 20:50:34  rj
++ * ``#error "..."'' instead of ``#error ...''.
++ *
++ * changed `_' to `-' in file names.
++ *
++ * Revision 1.4  1995/02/18  16:17:44  rj
++ * utilize either isinf(3) or finite(3), whatever happens to be present.
++ *
++ * Revision 1.3  1994/08/31  23:48:45  rj
++ * more portable .h file inclusion.
++ *
++ * Revision 1.2  1994/08/31  08:59:39  rj
++ * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
++ *
++ */
++
++#include <stdio.h>
++
++#include "asn-incl.h"
++
++int TestAsnBuffers();
++int TestAsnTag();
++int TestAsnLen();
++int TestAsnBool();
++int TestAsnInt();
++int TestAsnReal();
++int TestAsnOcts();
++int TestAsnBits();
++int TestAsnOid();
++int TestAsnList();
++
++int bufSize = 256;
++
++int
++main()
++{
++    int isErr = FALSE;
++
++    /* set up the PLUS and MINUS INFINITY globals */
++    InitAsnInfinity();
++
++    /* needed for OCTET STRING, BIT STRING and OBJECT IDENTIFIER decoding */
++    InitNibbleMem (256, 256);
++
++    if (!TestAsnBuffers())
++    {
++        fprintf (stdout, "Failed buffer tests, no point in proceeding ... bye!\n");
++        return 1;
++    }
++
++
++    if (!TestAsnTag())
++    {
++        fprintf (stdout, "Failed Tag test.\n" );
++        isErr = TRUE;
++    }
++
++    if (!TestAsnLen())
++    {
++        fprintf (stdout, "Failed Length test.\n" );
++        isErr = TRUE;
++    }
++
++    if (!TestAsnBool())
++    {
++        fprintf (stdout, "Failed BOOLEAN test.\n" );
++        isErr = TRUE;
++    }
++
++
++    if (!TestAsnInt())
++    {
++        fprintf (stdout, "Failed INTEGER test.\n" );
++        isErr = TRUE;
++    }
++
++    if (!TestAsnOcts())
++    {
++        fprintf (stdout, "Failed OCTET STRING test.\n" );
++        isErr = TRUE;
++    }
++
++
++    if (!TestAsnBits())
++    {
++        fprintf (stdout, "Failed BIT STRING test.\n" );
++        isErr = TRUE;
++    }
++
++
++    if (!TestAsnOid())
++    {
++        fprintf (stdout, "Failed OBJECT IDENTIFIER test.\n" );
++        isErr = TRUE;
++    }
++
++
++    if (!TestAsnReal())
++    {
++        fprintf (stdout, "Failed REAL test.\n" );
++        isErr = TRUE;
++    }
++
++
++
++    if (isErr)
++    {
++        fprintf (stdout, "There are errors in the primitive type encoding/decoding\n" );
++        fprintf (stdout, "library for this architecture.  Time for gdb...\n" );
++    }
++    else
++    {
++        fprintf (stdout, "The primitive type encoding/decoding library passed simple tests.\n");
++        fprintf (stdout, "It should be safe to use...\n" );
++    }
++
++    return isErr;
++}
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnBuffers()
++{
++    int i,j;
++    int noErr = TRUE;
++    SBuf  b;
++    char bufData[256];
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++    SBufResetInWriteRvsMode (&b);
++
++    /*
++     * write whole range of byte (0..255)
++     * remember, write works in reverse
++     */
++    for (i = 0; i < 256; i++)
++        BufPutByteRvs (&b,i);
++
++    if (BufWriteError (&b))
++    {
++        fprintf (stdout, "Error writing to buffer.\n" );
++        noErr = FALSE;
++    }
++
++    /* read in values & verify */
++    SBufResetInReadMode (&b);
++    for (i = 255; i >= 0; i--)
++        if (BufGetByte (&b) != i)
++        {
++            fprintf (stdout, "Error verifying data written to buffer.\n" );
++            noErr = FALSE;
++        }
++
++    if (BufReadError (&b))
++    {
++        fprintf (stdout, "Error reading from buffer.\n" );
++        noErr = FALSE;
++    }
++
++
++    /* now make sure errors are detected */
++    SBufResetInWriteRvsMode (&b);
++
++    for (i = 0; i < 257; i++) /*  write past end of buffer */
++        BufPutByteRvs (&b,0);
++
++    if (!BufWriteError (&b))
++    {
++        fprintf (stdout, "Buffers failed to report buffer write overflow.\n" );
++        noErr = FALSE;
++    }
++
++
++    SBufResetInReadMode (&b);
++    for (i = 256; i >= 0; i--)  /*  read past end of buffer  */
++        BufGetByte (&b);
++
++    if (!BufReadError (&b))
++    {
++        fprintf (stdout, "Buffers failed to report buffer read overflow.\n" );
++        noErr = FALSE;
++    }
++
++    return noErr;
++}  /* TestAsnBuffers */
++
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnTag()
++{
++    AsnTag aTag1;
++    AsnTag aTag2;
++    int i, j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++    BER_CLASS class;
++    BER_FORM form;
++    BER_UNIV_CODE code;
++
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++
++    /* encode a true value and verify */
++    class = UNIV;
++    form = PRIM;
++    code = INTEGER_TAG_CODE;
++    aTag1 = MAKE_TAG_ID (class, form, code);
++
++    for (i = 0; i < 2; i++)
++    {
++        SBufResetInWriteRvsMode (&b);
++        len1 = BEncTag1 (&b, class, form, code);
++
++        if (BufWriteError (&b))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error encoding a Tag.\n" );
++        }
++
++        SBufResetInReadMode (&b);
++
++        aTag2 = 0;
++
++        /* make sure no decode errors and that it decodes to same tag */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            aTag2 = BDecTag (&b, &len2, env);
++        }
++        else
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding a Tag - error number %d\n", val);
++        }
++        if (noErr && ((aTag2 != aTag1) || (len1 != len2)))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoded Tag does not match encoded Tag.\n" );
++        }
++        /* set a new test tag value */
++        class = CNTX;
++        form = CONS;
++        code = 29;
++        aTag1 = MAKE_TAG_ID (class, form, code);
++    }
++    return noErr;
++}  /* TestAsnTag */
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnLen()
++{
++    AsnLen aLen1;
++    AsnLen aLen2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++
++    /* encode a true value and verify */
++    aLen1 = 99999;
++    for (i = 0; i < 2; i++)
++    {
++        SBufResetInWriteRvsMode (&b);
++        len1 = BEncDefLen (&b, aLen1);
++
++        if (BufWriteError (&b))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error encoding Length.\n" );
++        }
++
++        SBufResetInReadMode (&b);
++
++        aLen2 = 0;
++
++        /* make sure no decode errors and that it decodes to true */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            aLen2 = BDecLen (&b, &len2, env);
++        }
++        else
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding Length - error number %d\n", val);
++        }
++
++
++        if (noErr && ((aLen2 != aLen1) || (len1 != len2)))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error - decoded lenght does not match encoded length\n");
++        }
++        aLen1 = 2;
++    }
++
++
++    /* test indef len */
++    SBufResetInWriteRvsMode (&b);
++    len1 = BEncIndefLen (&b);
++
++    if (BufWriteError (&b))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error encoding indefinite Length.\n" );
++    }
++
++    SBufResetInReadMode (&b);
++
++    aLen2 = 0;
++
++    /* make sure no decode errors */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        aLen2 = BDecLen (&b, &len2, env);
++    }
++    else
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding Length - error number %d\n", val);
++    }
++
++
++    if (noErr && ((aLen2 != INDEFINITE_LEN) || (len1 != len2)))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error - decoded length does not match encoded length\n");
++    }
++
++    /* test EOC */
++    SBufResetInWriteRvsMode (&b);
++    len1 = BEncEoc (&b);
++
++    if (BufWriteError (&b))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error encoding indefinite Length.\n" );
++    }
++
++    SBufResetInReadMode (&b);
++
++    aLen2 = 0;
++
++    /* make sure no decode errors */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecEoc (&b, &len2, env);
++    }
++    else
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding Length - error number %d\n", val);
++    }
++
++
++    if (noErr && (len1 != len2))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error - decoded EOC length error.\n");
++    }
++
++    return noErr;
++}  /* TestAsnLen */
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnBool()
++{
++    AsnBool aBool1;
++    AsnBool aBool2;
++    int j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++    SBufResetInWriteRvsMode (&b);
++
++    /* encode a true value and verify */
++    aBool1 = TRUE;
++    len1 = BEncAsnBoolContent (&b, &aBool1);
++
++    if (BufWriteError (&b))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error encoding TRUE BOOLEAN value.\n" );
++    }
++
++    SBufResetInReadMode (&b);
++
++    aBool2 = FALSE; /* set to opposite of expected value */
++
++    /* make sure no decode errors and that it decodes to true */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecAsnBoolContent (&b, tag, len1, &aBool2, &len2, env);
++    }
++    else
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding a BOOLEAN - error number %d\n", val);
++    }
++
++
++    if (noErr && ((aBool2 != aBool1) || (len1 != len2)))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding TRUE BOOLEAN value.\n" );
++    }
++
++    /* now encode a false value and verify */
++    SBufResetInWriteRvsMode (&b);
++    aBool1 = FALSE;
++
++    len1 = BEncAsnBoolContent (&b, &aBool1);
++    if (BufWriteError (&b))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error encoding FALSE BOOLEAN value.\n" );
++    }
++
++    SBufResetInReadMode (&b);
++
++    aBool2 = TRUE; /* set to opposite of expected value */
++
++    /* make sure no decode errors and that it decodes to true */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecAsnBoolContent (&b, tag, len1, &aBool2, &len2, env);
++    }
++    else
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding a BOOLEAN - error number %d\n", val);
++    }
++
++
++    if (noErr && ((aBool2 != aBool1) || (len1 != len2)))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding TRUE BOOLEAN value.\n" );
++    }
++
++    /* make sure no decode errors and that it decodes to false */
++
++    return noErr;
++}  /* TestAsnBool */
++
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnInt()
++{
++    AsnInt a1;
++    AsnInt a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++    int sign;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++    /*
++     * Encode a range of integers: negative & positive in
++     * the 1 to sizeof (AsnInt) range
++     */
++    sign = 1;
++    for (j = 0; j < 2; j++)
++    {
++        for (i = 0; i < sizeof (AsnInt); i++)
++        {
++            SBufResetInWriteRvsMode (&b);
++
++            a1 = sign * (17 << (i * 8)); /* 17 is a random choice :) */
++            len1 = BEncAsnIntContent (&b, &a1);
++            if (BufWriteError (&b))
++            {
++                noErr = FALSE;
++                fprintf (stdout, "Error encoding INTEGER value %d.\n", a1 );
++            }
++
++            SBufResetInReadMode (&b);
++
++            /* make sure no decode errors and that it decodes to true */
++            len2 = 0;
++            if ((val = setjmp (env)) == 0)
++            {
++                BDecAsnIntContent (&b, tag, len1, &a2, &len2, env);
++            }
++            else
++            {
++                noErr = FALSE;
++                fprintf (stdout, "Error decoding a INTEGER - error number %d\n", val);
++            }
++
++            if (noErr && ((a2 != a1) || (len1 != len2)))
++            {
++                noErr = FALSE;
++                fprintf (stdout, "Error decoding INTEGER value %d.\n", a1 );
++            }
++        }
++        sign = -1;
++    }
++
++    return noErr;
++
++}  /* TestAsnInt */
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnOcts()
++{
++    AsnOcts a1;
++    AsnOcts a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++    a1.octs = "Hello Gumby";
++    a1.octetLen = strlen (a1.octs);
++
++    /*
++     * octet string decoder needs to know tag form
++     * (snacc always encodes octet strings as primitives)
++     */
++    tag = MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE);
++
++    for (j = 0; j < 2; j++)
++    {
++        SBufResetInWriteRvsMode (&b);
++
++        len1 = BEncAsnOctsContent (&b, &a1);
++        if (BufWriteError (&b))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error encoding OCTET STRING value \"%s\".\n", a1.octs );
++        }
++        SBufResetInReadMode (&b);
++
++        /* make sure no decode errors and that it decodes to true */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            BDecAsnOctsContent (&b, tag, len1, &a2, &len2, env);
++        }
++        else
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding an OCTET STRING - error number %d\n", val);
++        }
++
++        if (noErr && (!AsnOctsEquiv (&a2,&a1) || (len1 != len2)))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding OCTET STRING value %s.\n", a1.octs );
++        }
++        a1.octs = ""; /* test empty string */
++        a1.octetLen = strlen (a1.octs);
++    }
++
++    ResetNibbleMem();
++    return noErr;
++
++}  /* TestAsnOcts */
++
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnBits()
++{
++    AsnBits a1;
++    AsnBits a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++    short bitsToSet[35];
++
++    /*
++     * init bitsToSet - old compilers don't support automatic init
++     * of aggregate types.
++     */
++    bitsToSet[0] = 0;
++    bitsToSet[1] = 1;
++    bitsToSet[2] = 0;
++    bitsToSet[3] = 0;
++    bitsToSet[4] = 1;
++    bitsToSet[5] = 1;
++    bitsToSet[6] = 0;
++    bitsToSet[7] = 1;
++    bitsToSet[8] = 0;
++    bitsToSet[9] = 1;
++    bitsToSet[10] = 0;
++    bitsToSet[11] = 0;
++    bitsToSet[12] = 1;
++    bitsToSet[13] = 1;
++    bitsToSet[14] = 0;
++    bitsToSet[15] = 1;
++    bitsToSet[16] = 0;
++    bitsToSet[17] = 1;
++    bitsToSet[18] = 0;
++    bitsToSet[19] = 0;
++    bitsToSet[20] = 1;
++    bitsToSet[21] = 1;
++    bitsToSet[22] = 0;
++    bitsToSet[23] = 1;
++    bitsToSet[24] = 0;
++    bitsToSet[25] = 1;
++    bitsToSet[26] = 0;
++    bitsToSet[27] = 1;
++    bitsToSet[28] = 1;
++    bitsToSet[29] = 0;
++    bitsToSet[30] = 1;
++    bitsToSet[31] = 1;
++    bitsToSet[32] = 0;
++    bitsToSet[33] = 1;
++    bitsToSet[34] = 0;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++    /* initialize bit string */
++    a1.bits = Asn1Alloc (5);
++    a1.bitLen = 35;
++    for (i = 0; i < 35; i++)
++    {
++        if (bitsToSet[i])
++            SetAsnBit (&a1, i);
++        else
++            ClrAsnBit (&a1, i);
++    }
++
++    /*
++     * bit string decoder needs to know tag form
++     * (snacc always encodes bit strings as primitives)
++     */
++    tag = MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE);
++
++    SBufResetInWriteRvsMode (&b);
++
++    len1 = BEncAsnBitsContent (&b, &a1);
++    if (BufWriteError (&b))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error encoding BIT STRING value ");
++        PrintAsnBits (stdout, &a1, 0);
++        fprintf (stdout, "\n");
++    }
++    SBufResetInReadMode (&b);
++
++    /* make sure no decode errors and that it decodes to true */
++    len2 = 0;
++    if ((val = setjmp (env)) == 0)
++    {
++        BDecAsnBitsContent (&b, tag, len1, &a2, &len2, env);
++    }
++    else
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding an BIT STRING - error number %d\n", val);
++    }
++
++    if (noErr && (!AsnBitsEquiv (&a2,&a1) || (len1 != len2)))
++    {
++        noErr = FALSE;
++        fprintf (stdout, "Error decoding BIT STRING value ");
++        PrintAsnBits (stdout, &a1, 0);
++        fprintf (stdout, "\n");
++    }
++    ResetNibbleMem();
++    return noErr;
++
++}  /* TestAsnBits */
++
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnOid()
++{
++    AsnOid a1;
++    AsnOid a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++    /*  mib-2 oid  { iso 3 6 1 2 1 }*/
++     a1.octetLen = 5;
++     a1.octs = "\53\6\1\2\1";
++
++
++    for (j = 0; j < 2; j++)
++    {
++        SBufResetInWriteRvsMode (&b);
++
++        len1 = BEncAsnOidContent (&b, &a1);
++        if (BufWriteError (&b))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error encoding OCTET STRING value \"%s\".\n", a1.octs );
++        }
++        SBufResetInReadMode (&b);
++
++        /* make sure no decode errors and that it decodes to true */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            BDecAsnOidContent (&b, tag, len1, &a2, &len2, env);
++        }
++        else
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding an OCTET STRING - error number %d\n", val);
++        }
++
++        if (noErr && (!AsnOidsEquiv (&a2,&a1) || (len1 != len2)))
++        {
++            noErr = FALSE;
++            fprintf (stdout, "Error decoding OCTET STRING value %s.\n", a1.octs );
++        }
++        /*  system  { mib-2 1 }*/
++        a1.octs = "\53\6\1\2\1\1";
++        a1.octetLen = 6;
++    }
++    ResetNibbleMem();
++    return noErr;
++
++}  /* TestAsnOid */
++
++/*
++ * returns TRUE if passes encode/decode tests
++ */
++int
++TestAsnReal()
++{
++    AsnReal a1[5];
++    AsnReal a2;
++    int i,j;
++    AsnLen len1;
++    AsnLen len2;
++    AsnTag tag;
++    int noErr = TRUE;
++    int elmtErr = FALSE;
++    ENV_TYPE env;
++    SBuf  b;
++    char bufData[256];
++    long int val;
++    int sign;
++    AsnReal inf;
++    unsigned char *c;
++
++
++    /*
++     * if you do not have the ieee_functions in your math lib,
++     * this will not link.  Comment it out and cross you fingers.
++     * (or check/set the +/-infinity values for you architecture)
++     */
++#if HAVE_ISINF
++    if (!isinf (PLUS_INFINITY) || !isinf (MINUS_INFINITY))
++#else
++#if HAVE_FINITE
++    if (finite (PLUS_INFINITY) || finite (MINUS_INFINITY))
++#else
++  #error "oops: you've got neither isinf(3) nor finite(3)?!"
++#endif
++#endif
++    {
++        fprintf (stdout, "WARNING: PLUS_INFINITY and MINUS_INFINITY in asn_real.c are not\n");
++        fprintf (stdout, "correct for this architecture.  Modify the InitAsnInfinity() Routine.\n");
++    }
++
++    /*
++     * init test value array.
++     * some old compilers don't support automatic init of aggregate types
++     * like:
++     * AsnReal a1[] = { 0.0, 0.8, -22.484848, PLUS_INFINITY, MINUS_INFINITY};
++     */
++    a1[0] = 0.0;
++    a1[1] = 0.8;
++    a1[2] = -22.484848;
++    a1[3] = PLUS_INFINITY;
++    a1[4] = MINUS_INFINITY;
++
++    /* initialize buffer */
++    SBufInit (&b, bufData, 256);
++
++    /*
++     * Encode a range of integers: negative & positive in
++     * the 1 to sizeof (AsnInt) range
++     */
++    for (i = 0; i < 5; i++)
++    {
++        elmtErr = FALSE;
++        SBufResetInWriteRvsMode (&b);
++
++        len1 = BEncAsnRealContent (&b, &a1[i]);
++        if (BufWriteError (&b))
++        {
++            elmtErr = TRUE;
++            fprintf (stdout, "Error encoding REAL value ");
++            PrintAsnReal (stdout,&a1[i],0);
++            fprintf (stdout, ".\n");
++        }
++
++        SBufResetInReadMode (&b);
++
++        /* make sure no decode errors and that it decodes to true */
++        len2 = 0;
++        if ((val = setjmp (env)) == 0)
++        {
++            BDecAsnRealContent (&b, tag, len1, &a2, &len2, env);
++        }
++        else
++        {
++            elmtErr = TRUE;
++            fprintf (stdout, "Error decoding a REAL - error number %d\n", val);
++        }
++
++        /* testing reals for equality is sketchy */
++        if (!elmtErr && ((a2 != a1[i]) || (len1 != len2)))
++        {
++
++            elmtErr = TRUE;
++            fprintf (stdout, "Error decoding REAL value ");
++            PrintAsnReal (stdout, &a1[i], 0);
++            fprintf (stdout, ".\n");
++
++            if (len1 == len2)  /* therefore a2 != a1[i] */
++            {
++                fprintf (stdout, "The value decoded was ");
++                PrintAsnReal (stdout, &a2, 0);
++                fprintf (stdout, ".\n");
++            }
++            else
++                fprintf (stdout, "The encoded and decoded length disagree.\n");
++        }
++        if (elmtErr)
++            noErr = FALSE;
++    }
++
++
++    return noErr;
++
++}  /* TestAsnReal */
+diff -uraN snacc-1.3bbn/tbl-example/README snacc-1.3b4/tbl-example/README
+--- snacc-1.3bbn/tbl-example/README	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/tbl-example/README	1997-02-15 19:33:24.000000000 +0000
+@@ -0,0 +1,83 @@
++(RCS control information is at the end of this file.)
++
++
++Table encoder/decoder example README - MS 93
++------------------------------------
++
++This directory contains an example that shows:
++
++   1. the process of creating and using tables.
++   2. examples of decoding, printing, and encoding.
++
++
++To dive right in just type "make" in this directory.  That will
++create the "example" executable (you should have previously installed
++the snacc and mkchdr progs and the table library).
++
++Then type:
++
++ make check
++
++and see what happens. Look in example.c and makefile to see how things
++work.
++
++
++
++Questions and Answers
++---------------------
++
++Q. What is a table? (also refered to a type table or type tree)
++
++A. A table is simply a data structure that holds a description of
++   the types from an ASN.1 module.  This table can then be used
++   by a number of "generic" routines to do ASN.1 related (BER
++   encoding/decoding) or other useful things such as printing
++   values, freeing values and whatever else you can dream up.
++
++
++Q. How do I create a table from my ASN.1 source files?
++
++A. Run snacc with the -T option, e.g.:
++
++     snacc -T mytbls.tt myMod1.asn1 myMod2.asn1
++
++   the above command will create the "mytbls.tt" file that
++   holds the descriptions of the ASN.1 types in the "myMod1.asn1"
++   and "myMod2.asn1" files. (look in the makefile in this directory)
++
++
++Q. Why is there only a C interface to tables?
++
++A. Time. Tables drivers create/read/free these types
++   without having seen a typedef for them.  The C implementation
++   uses some assumptions about how structures etc. are allocated
++   and accessed.  With C++ this is much more difficult.  It can
++   be done but required more time than I had.
++
++
++Q. Ok, tables sound great, what's the catch?
++
++A. Well,
++
++   1. table driven encoding and decoding is something like
++      4 times slower than the C or C++ version.
++      (but tables are *way* smaller than the .o's for the compiled approach)
++   2. the ANY DEFINED BY stuff is not supported at all.
++   3. subtype information is not included in the tables (time crunch again)
++      (PER encoders/decoders will need the subtype info)
++   4. Values from the ASN.1 source are not included in the table.
++
++   If you have the time and skills, you can fix 2, 3 and 4.  1 is harder.
++
++
++
++Q.  Tell me more.
++
++A.  Look at the manual. (in .../doc/)
++
++#-------------------------------------------------------------------------------
++# $Header$
++# $Log$
++# Revision 1.1  1997/02/15 19:33:24  rj
++# first check-in
++#
+diff -uraN snacc-1.3bbn/tbl-example/example.c snacc-1.3b4/tbl-example/example.c
+--- snacc-1.3bbn/tbl-example/example.c	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/tbl-example/example.c	1997-02-15 19:33:26.000000000 +0000
+@@ -0,0 +1,174 @@
++/*
++ * file: .../tbl-example/example.c - decodes and prints a given BER
++ * PersonnelRecord value and re-encodes it to the file
++ * "p-rec.out.ber".  This example would be similar to your user code in
++ * that you run "mkchdr" to build a nicely named description of data
++ * structure (PersonnelRecord in this case).  The table tools deal with
++ * the same data structure in a generic way and don't use/need mkchdr.
++ * You must not change the output of mkchdr otherwise the table encoder
++ * decoder, etc will not understand it.
++ *
++ * Mike Sample
++ *
++ * Copyright (C) 1993 Michael Sample
++ *            and the University of British Columbia
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program and the associated libraries are distributed in the hope
++ * that they will be useful, but WITHOUT ANY WARRANTY; without even the
++ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
++ * PURPOSE.  See the GNU General Public License and GNU Library General
++ * Public License for more details.
++ *
++ * $Header$
++ * $Log$
++ * Revision 1.1  1997/02/15 19:33:26  rj
++ * first check-in
++ *
++ */
++
++#include "tbl-incl.h"
++#include "exp-buf.h"
++#include "sbuf.h"
++
++#include "p-rec.h"  /* include the file we made with mkchdr */
++
++
++char *outputFileNameG = "p-rec.out.ber";
++
++void Usage PARAMS ((prg),
++    char *prg)
++{
++    fprintf (stderr, "Usage: %s <tt file name> <p-rec ber file> \n\n", prg);
++    fprintf (stderr, "E.g.  %s p-rec.tt  p-rec.ber\n\n", prg);
++    fprintf (stderr, "The BER values in the file list will be decoded, printed to stdout and then re-encoded to the file \"%s\"\n", outputFileNameG);
++}
++
++
++int
++main PARAMS ((argc, argv),
++    int argc _AND_
++    char **argv)
++{
++    char *tblFileName;
++    char *berFileName;
++    TBL *tbl;
++    int i;
++    char *fileData;
++    unsigned long int fsize;
++    PersonnelRecord *val;
++    unsigned long int bytesDecoded;
++    unsigned long int bytesEncoded;
++    SBuf sb;  /* use simple buffers for reading in (know sizes) */
++    ExpBuf *ebPtr; /* use expanding bufs for enc (usually don't know sizes)*/
++    GenBuf gb;
++    FILE *outputFile;
++
++
++
++    if (argc != 3)
++    {
++        Usage (argv[0]);
++        return 1;
++    }
++
++    tblFileName = argv[1];
++    berFileName = argv[2];
++
++    /* init mem pool to hold  decoded val */
++    InitNibbleMem (1024, 1024);
++
++    /* read in and decode the type table */
++    tbl = LoadTblFile (tblFileName);
++    if (tbl == NULL)
++        return 1;
++
++    fileData = LoadFile (berFileName, &fsize);
++    if (fileData == NULL)
++        return 1;
++
++    SBufInstallData (&sb, fileData, fsize);
++    PutSBufInGenBuf (&sb, &gb);
++
++    fprintf (stdout, "\n\n-- decoded contents of BER PersonnelRecord file: \"%s\"--\n", berFileName);
++
++    val = TblDecode (tbl, NULL, "PersonnelRecord", &gb, &bytesDecoded);
++
++    if (val == NULL)
++        fprintf (stdout, "-- Decoding error occured somewhere -- \n");
++    else
++        TblPrintValue (tbl, NULL, "PersonnelRecord", stdout, val);
++
++    fprintf (stdout, "\n\n -- decoded %d bytes for the above value --\n\n", bytesDecoded, berFileName);
++
++    free (fileData); /* was malloc'd in LoadFile */
++
++    /*
++     * process value here
++     * (This is where the header file generated by mkchdr is
++     * useful - you can access the decoded value in a standard
++     * /easier way).
++     *
++     * Ok, well, the names "field0" etc aren't that nice
++     * but what did you expect - they aren't named in the ASN.1
++     * spec so mkchdr just makes them up.  To fix this, just
++     * add field names to you ASN.1 spec - it will not change the
++     * way the values are encoded - so you're not making it
++     * incompatible with the original. (not including value notation)
++     */
++    printf ("The following printout is an example of using the\n");
++    printf ("hdr file generated by mkchdr to access the data\n");
++    printf ("returned from the table decoder.  Look in \"example.c\"\n\n");
++
++
++    printf ("***** JQ GUMBY & CO Database *****************************************\n");
++    printf ("Employee Name:      %s %s %s\n", val->field0->givenName->octs, val->field0->initial->octs, val->field0->familyName->octs);
++    printf ("Title:              %s\n", val->title->octs);
++    printf ("Employee Number:    %d\n", *val->field1);
++    printf ("Date of Hire:       %s\n", val->dateOfHire->octs);
++    printf ("Name of Spouse:     %s %s %s\n", val->nameOfSpouse->givenName->octs, val->nameOfSpouse->initial->octs, val->nameOfSpouse->familyName->octs);
++    printf ("Number of Children: %d\n", AsnListCount (val->children));
++    printf ("**********************************************************************\n\n");
++
++    /*
++     * finished playing with the decoded value.
++     * now re-encode the value.  Using an expbuf to hold the encoded val
++     * because they can grow and in general you can predict a values
++     * encoded size (although we could assume that is would be close to
++     * the same size as the one we read in at the beginning of this prg).
++     * (note: the size of PersonnelRecord BER value we decoded may be
++     * different from the size of the re-encoded version depending on
++     * the use of indefinite or definite lengths.  Both are valid BER.)
++     */
++    fprintf (stdout, "now re-encoding the PersonnelRecord value to \"%s\"\n", outputFileNameG);
++
++    ebPtr = ExpBufAllocBufAndData();
++    ExpBufResetInWriteRvsMode (ebPtr); /* set up to hold encoding (= writing) */
++
++    PutExpBufInGenBuf (ebPtr, &gb);
++
++    if (TblEncode (tbl, NULL, "PersonnelRecord", &gb, val, &bytesEncoded) < 0)
++        fprintf (stderr, "main: error encoding the PersonnelRecord\n");
++
++    /* copy ExpBuf data to file */
++    outputFile = fopen (outputFileNameG, "w");
++    if (outputFile == NULL)
++    {
++        fprintf (stderr, "error - could not open file \"%s\"\n", outputFileNameG);
++        perror ("main: fopen:");
++    }
++
++    ExpBufCopyToFile (ebPtr, outputFile);
++
++    fclose (outputFile);
++
++    /* free the encoded version */
++    ExpBufFreeBufAndDataList (ebPtr);
++
++
++    return 0;
++} /* main */
+diff -uraN snacc-1.3bbn/tbl-example/makefile snacc-1.3b4/tbl-example/makefile
+--- snacc-1.3bbn/tbl-example/makefile	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/tbl-example/makefile	1997-02-15 19:33:26.000000000 +0000
+@@ -0,0 +1,82 @@
++# file: .../tbl-example/makefile
++#
++# $Header$
++# $Log$
++# Revision 1.1  1997/02/15 19:33:26  rj
++# first check-in
++#
++
++include ../makehead
++
++TOP		= ..
++
++ASN1_SRC_DIR	= $(TOP)/asn1specs
++
++ASN1_C_LIB_DIR	= $(TOP)/c-lib
++ASN1_C_INC_DIR	= $(ASN1_C_LIB_DIR)/inc
++TTBL_ASN1_LIB	= $(ASN1_C_LIB_DIR)/libasn1ctbl.a
++
++COMPILERDIR	= $(TOP)/compiler
++SNACC		= $(COMPILERDIR)/snacc
++USEFUL_TYPES	= $(ASN1_SRC_DIR)/asn-useful.asn1
++SNACCFLAGS	= -u $(USEFUL_TYPES)
++
++TBLTOOLSDIR	= $(TOP)/tbl-tools
++MKHDR		= $(TBLTOOLSDIR)/mkchdr/mkchdr
++
++ASN1FILES	= $(ASN1_SRC_DIR)/p-rec.asn1
++ASN1TTFILE	= p-rec.tt
++ASN1TTHFILE	= p-rec.h
++
++CFILES	= example.c
++OFILES	= example.o
++
++DISTFILES = \
++	README		\
++	makefile	\
++	$(CFILES)	\
++	p-rec.ber
++
++CPPFLAGS	+= -I$(TOP) -I$(ASN1_C_INC_DIR) -DUSE_GEN_BUF
++
++#-------------------------------------------------------------------------------
++
++all::		example
++
++example:	$(OFILES) $(TTBL_ASN1_LIB)
++		$(REASON)
++		$(CC) $(CFLAGS) -o example $(OFILES) $(TTBL_ASN1_LIB) $(LIBS)
++
++$(ASN1TTFILE):	$(ASN1FILES)
++		$(REASON)
++		$(SNACC) $(SNACCFLAGS) -T $@ $(ASN1FILES)
++
++$(SNACC) $(MKHDR):
++		cd $(@D) && $(MAKE) $(@F)
++
++$(TTBL_ASN1_LIB):
++		cd $(@D) && $(MAKE) tbl-lib
++
++$(ASN1TTHFILE):	$(ASN1TTFILE)
++		$(REASON)
++		$(MKHDR) $? $@
++
++check::		example $(ASN1TTFILE)
++
++check::
++		./example p-rec.tt p-rec.ber
++		cmp p-rec.ber p-rec.out.ber
++		@echo "+++ the test was successful"
++
++# dummy:
++install::
++
++clean::
++		$(RM) example *.o *~ core .emacs* $(ASN1TTFILE) $(ASN1TTHFILE) p-rec.out.ber
++
++depend::
++		$(MAKE) $(MKHDR)
++
++depend::	$(ASN1TTHFILE)
++
++include ../maketail
+diff -uraN snacc-1.3bbn/tbl-example/p-rec.ber.uu snacc-1.3b4/tbl-example/p-rec.ber.uu
+--- snacc-1.3bbn/tbl-example/p-rec.ber.uu	1970-01-01 00:00:00.000000000 +0000
++++ snacc-1.3b4/tbl-example/p-rec.ber.uu	2005-07-30 16:57:00.588101736 +0000
+@@ -0,0 +1,7 @@
++begin 644 p-rec.ber
++M8(&.81`6!$IO:&X6`446!5-M:71HH!`6#E1H92!":6<@0VAE97-E7X$``P&&
++MGZ$*0P@Q.3@R,#$P-*(281`6!$UA<GD6`4P6!5-M:71HHT$Q'V$1%@5*86UE
++M<Q8!4A8%4VUI=&B@"D,(,3DU-S`S,3`Q'F$0%@1,:7-A%@%-%@53;6ET:*`*
++*0P@Q.38Q,#8R,0``
++`
++end
--- snacc-1.3bbn.orig/debian/libsnacc-dev.install
+++ snacc-1.3bbn/debian/libsnacc-dev.install
@@ -0,0 +1,20 @@
+debian/tmp/usr/include/snacc/c
+debian/tmp/usr/include/snacc/c++
+debian/tmp/usr/lib/libasn1c++.a
+debian/tmp/usr/lib/libasn1c++.la
+debian/tmp/usr/lib/libasn1c++.so
+debian/tmp/usr/lib/libasn1cCebuf.a
+debian/tmp/usr/lib/libasn1cCebuf.la
+debian/tmp/usr/lib/libasn1cCebuf.so
+debian/tmp/usr/lib/libasn1cebuf.a
+debian/tmp/usr/lib/libasn1cebuf.la
+debian/tmp/usr/lib/libasn1cebuf.so
+debian/tmp/usr/lib/libasn1cmbuf.a
+debian/tmp/usr/lib/libasn1cmbuf.la
+debian/tmp/usr/lib/libasn1cmbuf.so
+debian/tmp/usr/lib/libasn1csbuf.a
+debian/tmp/usr/lib/libasn1csbuf.la
+debian/tmp/usr/lib/libasn1csbuf.so
+debian/tmp/usr/lib/libasn1ctbl.a
+debian/tmp/usr/lib/libasn1ctbl.la
+debian/tmp/usr/lib/libasn1ctbl.so
--- snacc-1.3bbn.orig/debian/control
+++ snacc-1.3bbn/debian/control
@@ -0,0 +1,69 @@
+Source: snacc
+Section: devel
+Priority: optional
+Maintainer: Debian FDT tools team <pkg-fdt-tools-team@lists.alioth.debian.org>
+Uploaders: W. Borgert <debacle@debian.org>, Michael Piefel <piefel@debian.org>
+Build-Depends: cdbs, autoconf, automake1.7, autotools-dev, libtool, debhelper (>> 4), bison, flex, docbook-xsl (>= 1.60), xsltproc
+Standards-Version: 3.6.2.1
+
+Package: snacc
+Architecture: any
+Depends: ${shlibs:Depends}
+Recommends: libsnacc-dev, snacc-doc
+Suggests: automake
+Description: ASN.1 to C or C++ or IDL compiler
+ Snacc is short for "Sample Neufeld ASN.1 to C Compiler" and ASN.1
+ stands for Abstract Syntax Notation One (ITU-T X.208/ISO 8824).
+ Snacc supports a subset of ASN.1 1988.  If you need features of
+ ASN.1 1992 or later, snacc is not for you.
+ .
+ Given an ASN.1 source file(s) snacc can produce:
+ .
+ 1. C routines for BER encoding, decoding, printing and freeing.
+ 2. C++ routines for BER encoding, decoding, and printing.
+ 3. A type table that can be used with C driver routines
+    for BER encoding, decoding, printing and freeing.
+ .
+ If you want to build snacc based applications, you want to install
+ the libsnacc-dev package, too.  Your application will then depend on
+ the snacc libraries, you find in the libsnacc0c2 package.
+
+Package: libsnacc-dev
+Architecture: any
+Depends: libsnacc0c2 (= ${Source-Version})
+Recommends: snacc-doc
+Description: ASN.1 to C or C++ or IDL compiler, development files
+ Snacc is short for "Sample Neufeld ASN.1 to C Compiler" and ASN.1
+ stands for Abstract Syntax Notation One (ITU-T X.208/ISO 8824).
+ Snacc supports a subset of ASN.1 1988.  If you need features of
+ ASN.1 1992 or later, snacc is not for you.
+ .
+ This package contains the static libraries and C/C++ header files for
+ snacc development.
+
+Package: libsnacc0c2
+Section: libs
+Architecture: any
+Depends: ${shlibs:Depends}
+Conflicts: libsnacc0
+Replaces: libsnacc0
+Description: ASN.1 to C or C++ or IDL compiler, shared libraries
+ Snacc is short for "Sample Neufeld ASN.1 to C Compiler" and ASN.1
+ stands for Abstract Syntax Notation One (ITU-T X.208/ISO 8824).
+ Snacc supports a subset of ASN.1 1988.  If you need features of
+ ASN.1 1992 or later, snacc is not for you.
+ .
+ These are the shared libraries for programs developed using snacc.
+
+Package: snacc-doc
+Section: doc
+Architecture: all
+Recommends: gv | postscript-viewer
+Suggests: make, tetex-bin
+Description: ASN.1 to C or C++ or IDL compiler, documentation
+ Snacc is short for "Sample Neufeld ASN.1 to C Compiler" and ASN.1
+ stands for Abstract Syntax Notation One (ITU-T X.208/ISO 8824).
+ Snacc supports a subset of ASN.1 1988.  If you need features of
+ ASN.1 1992 or later, snacc is not for you.
+ .
+ The documentation for snacc in PostScript format and LaTeX sources.
--- snacc-1.3bbn.orig/debian/dirs
+++ snacc-1.3bbn/debian/dirs
@@ -0,0 +1,12 @@
+usr/bin
+usr/include/snacc/asn1
+usr/include/snacc/c
+usr/include/snacc/c++
+usr/lib
+usr/share/aclocal
+usr/share/doc
+usr/share/doc/libsnacc-dev
+usr/share/doc/libsnacc0c2
+usr/share/doc/snacc
+usr/share/doc/snacc-doc
+usr/share/man/man1
--- snacc-1.3bbn.orig/debian/snacc-doc.doc-base
+++ snacc-1.3bbn/debian/snacc-doc.doc-base
@@ -0,0 +1,9 @@
+Document: snacc-doc
+Title: Snacc 1.2rj: A High Performance ASN.1 to C/C++/IDL Compiler
+Author: Michael Sample
+Abstract: This manual describes the Snacc ASN.1 to C/C++ compiler.
+Section: Apps/Programming
+
+Format: PostScript
+Files: /usr/share/doc/snacc-doc/snacc-a5.ps.gz
+
--- snacc-1.3bbn.orig/debian/changelog
+++ snacc-1.3bbn/debian/changelog
@@ -0,0 +1,103 @@
+snacc (1.3bbn-9) unstable; urgency=low
+
+  * Now build-depends on libtool (closes: #321199).
+
+ -- W. Borgert <debacle@debian.org>  Thu, 04 Aug 2005 18:40:05 +0000
+
+snacc (1.3bbn-8) unstable; urgency=low
+
+  * New maintainer:
+    Debian FDT tool team <pkg-fdt-tools-team@lists.alioth.debian.org>,
+    mainly Martin v. Löwis <martin@v.loewis.de>.
+    (Closes: #204807).
+    FDT = Formal Description Technique (e.g. ASN.1, MSC, SDL, TTCN-3)
+  * Port to standard C++ library (Martin).
+  * Rebuild for new C++ ABI (Martin).
+  * Replace EOC with EOC_TAG_ID (Martin) (Closes: #307760).
+  * Build uses CDBS, divided earlier changes in clean patches (me).
+  * Removed -dbg package temporarily (me).
+  * Fixes FTBFS on amd64 (Closes: #277690), thanks to Kurt Roeckx
+    <Q@ping.be> for reporting and Larry Doolittle
+    <ldoolitt@recycle.lbl.gov> for the patch.
+
+ -- W. Borgert <debacle@debian.org>  Sat, 30 Jul 2005 17:32:55 +0000
+
+snacc (1.3bbn-7) unstable; urgency=low
+
+  * QA upload.
+  * Manpages relicensed from GFDL to GNU GPL (closes: #292242)
+  * debian/rules: remove generated manpages on clean
+
+ -- Frederic Peters <fpeters@debian.org>  Wed, 26 Jan 2005 10:55:09 +0100
+
+snacc (1.3bbn-6) unstable; urgency=low
+
+  * QA upload.
+  * bootstrap:
+    + Fixed the autotools calling order.
+    + Re-ran the bootstrap script.
+  * debian/control:
+    + Do not build-depend on the autotools.
+    + Set policy to 3.6.1.1.
+    + Recommend gv | postscript-viewer instead of postscript-viewer only.
+  * debian/rules:
+    + Fix timestamps at configure time (Closes: #249740).
+    + Run make distclean, not merely make clean.
+    + Remove configure.in at clean time.
+    + Fixed {} wildcard bashisms.
+
+ -- Sam Hocevar (Debian packages) <sam+deb@zoy.org>  Tue, 10 Aug 2004 18:01:47 +0200
+
+snacc (1.3bbn-5.1) unstable; urgency=low
+
+  * g++-3.3: strstream.h is now strstream (closes: #197705).
+  * Orphaned the package.  Good-bye, snacc.
+  * Updated some ./debian/ files.
+
+ -- W. Borgert <debacle@debian.org>  Sun, 10 Aug 2003 10:40:47 +0200
+
+snacc (1.3bbn-5) unstable; urgency=low
+
+  * Fixed an incompatibility with new bison, thanks to Junichi Uekawa
+    (closes: #167051).
+  * Changed Debian specific manual pages from DocBook/SGML to DocBook/XML.
+  * Changed bootstrap and configure.in/ac to latest autotools.
+
+ -- W. Borgert <debacle@debian.org>  Tue, 19 Nov 2002 16:04:46 +0000
+
+snacc (1.3bbn-4) unstable; urgency=low
+
+  * Adjusted to new gcc version (closes: #133010).
+
+ -- W. Borgert <debacle@debian.org>  Wed, 13 Feb 2002 20:59:59 +0000
+
+snacc (1.3bbn-3) unstable; urgency=low
+
+  * Dependencies on autotools-dev etc. introduced (closes: #104708, #115058).
+
+ -- W. Borgert <debacle@debian.org>  Wed, 24 Oct 2001 23:24:08 +0000
+
+snacc (1.3bbn-2.1) unstable; urgency=low
+
+  * Update config.sub/guess so that snacc will build on ia64.
+    (closes: Bug#115058)
+
+ -- Doug Porter <dsp@debian.org>  Wed, 17 Oct 2001 12:13:20 -0600
+
+snacc (1.3bbn-2) unstable; urgency=low
+
+  * Builds binary-all package in binary-arch target (closes: #87203).
+  * libstdc++2.10-dev build dependency removed (closes: #92383).
+  * Fixed debian/rules: Overwrote right manual page with wrong one.
+  * Changes in control file, new package libsnacc-dbg etc.
+  * Use current libtool.
+
+ -- W. Borgert <debacle@debian.org>  Sun, 25 Feb 2001 13:42:05 +0000
+
+snacc (1.3bbn-1) unstable; urgency=low
+
+  * Initial Release.
+  * Fixed configure.in and snacc-config.in.
+
+ -- W. Borgert <debacle@debian.org>  Sat, 27 Jan 2001 01:18:46 +0000
+
--- snacc-1.3bbn.orig/debian/copyright
+++ snacc-1.3bbn/debian/copyright
@@ -0,0 +1,29 @@
+This package was debianised by W. Borgert <debacle@debian.org> on
+Sat, 2001-01-27 01:18:46 +0000.
+
+It was downloaded from http://www.ir.bbn.com/download/tools/\
+snacc-1.3.tar.gz and ftp://ftp.fokus.gmd.de/pub/freeware/\
+snacc/snacc-1.3b4.tar.gz (c-examples, c++-examples, tbl-example)
+
+Upstream Authors:
+
+M. Fredette <fredette@bbn.com>
+Mike Sample <msample@cs.ubc.ca>
+Gerald Neufeld <neufeld@cs.ubc.ca>
+Robert Joop  <rj@rainbow.in-berlin.de>
+Sebastian Wangnick  <sebastian.wangnick@eurocontrol.be>
+
+The snacc tool itself is covered by the GNU GPL, while the generated
+code and the libraries used by generated code are free to use for any
+purpose, even non-free software.
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+ On Debian GNU/Linux systems, the complete text of the GNU General Public
+ License can be found in the file /usr/share/common-licenses/GPL.
--- snacc-1.3bbn.orig/debian/docs
+++ snacc-1.3bbn/debian/docs
@@ -0,0 +1,2 @@
+NEWS
+README
--- snacc-1.3bbn.orig/debian/libsnacc0c2.install
+++ snacc-1.3bbn/debian/libsnacc0c2.install
@@ -0,0 +1,12 @@
+debian/tmp/usr/lib/libasn1cCebuf.so.0.0.0
+debian/tmp/usr/lib/libasn1cCebuf.so.0
+debian/tmp/usr/lib/libasn1cebuf.so.0.0.0
+debian/tmp/usr/lib/libasn1cebuf.so.0
+debian/tmp/usr/lib/libasn1cmbuf.so.0.0.0
+debian/tmp/usr/lib/libasn1cmbuf.so.0
+debian/tmp/usr/lib/libasn1csbuf.so.0.0.0
+debian/tmp/usr/lib/libasn1csbuf.so.0
+debian/tmp/usr/lib/libasn1ctbl.so.0.0.0
+debian/tmp/usr/lib/libasn1ctbl.so.0
+debian/tmp/usr/lib/libasn1c++.so.0.0.0
+debian/tmp/usr/lib/libasn1c++.so.0
--- snacc-1.3bbn.orig/debian/snacc-config.dbk
+++ snacc-1.3bbn/debian/snacc-config.dbk
@@ -0,0 +1,197 @@
+<?xml version='1.0' encoding='utf-8'?>
+<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
+"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
+  <!ENTITY dhfirstname "<firstname>W.</firstname>">
+  <!ENTITY dhsurname   "<surname>Borgert</surname>">
+  <!-- Please adjust the date whenever revising the manpage. -->
+  <!ENTITY dhdate      "<date>2001-02-17</date>">
+  <!ENTITY dhsection   "<manvolnum>1</manvolnum>">
+  <!ENTITY dhemail     "<email>debacle@debian.org</email>">
+  <!ENTITY dhusername  "W. Borgert">
+  <!ENTITY dhucpackage "<refentrytitle>snacc-config</refentrytitle>">
+  <!ENTITY dhpackage   "snacc-config">
+  <!ENTITY debian      "<productname>Debian GNU/Linux</productname>">
+  <!ENTITY gnu         "<acronym>GNU</acronym>">
+]>
+
+<!-- $Id$ -->
+
+<refentry>
+  <refentryinfo>
+    <address>
+      &dhemail;
+    </address>
+    <author>
+      &dhfirstname;
+      &dhsurname;
+    </author>
+    <copyright>
+      <year>2001</year>
+      <holder>&dhusername;</holder>
+    </copyright>
+    &dhdate;
+  </refentryinfo>
+  <refmeta>
+    &dhucpackage;
+
+    &dhsection;
+  </refmeta>
+  <refnamediv>
+    <refname>&dhpackage;</refname>
+
+    <refpurpose>script to get information about the installed version
+       of <command>snacc</command></refpurpose>
+  </refnamediv>
+  <refsynopsisdiv>
+    <cmdsynopsis>
+      <command>&dhpackage;</command>
+
+      <arg><option>--version</option></arg>
+
+      <arg><option>--prefix=<replaceable>DIR</replaceable></option></arg>
+
+      <arg><option>--exec-prefix=<replaceable>DIR</replaceable></option></arg>
+
+      <arg><option>--uninstalled=<replaceable>DIR</replaceable></option></arg>
+
+      <arg><option>--libtool</option></arg>
+
+      <arg><option>--cflags</option></arg>
+
+      <arg><option>--libs</option></arg>
+
+      <arg><option>--compiler</option></arg>
+
+      <arg><option>--asn1specs</option></arg>
+
+      <arg><option>--language=<replaceable>LANG (C or C++)</replaceable></option></arg>
+
+      <arg>BUFFERTYPE (one of ebuf, mbuf, sbuf, or tbl)</arg>
+
+    </cmdsynopsis>
+  </refsynopsisdiv>
+  <refsect1>
+    <title>Description</title>
+
+      <para><command>snacc-config</command> is a tool that is used to
+        configure to determine the compiler and linker flags that
+        should be used to compile and link programs that use
+        <command>snacc</command>.</para>
+
+  </refsect1>
+  <refsect1>
+    <title>Options</title>
+    <variablelist>
+      <varlistentry>
+	<term><option>--version</option></term>
+	<listitem>
+	  <para>Print the currently installed version of
+	    <command>snacc</command>.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--prefix=<replaceable>PREFIX</replaceable></option></term>
+	<listitem>
+	  <para>If specified, use <replaceable>PREFIX</replaceable>
+	    instead of the installation prefix that
+	    <command>snacc</command> was built with when computing the
+	    output for the <option>--cflags</option> and
+	    <option>--libs</option> options.  This option is normally
+	    not needed in &debian;.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--exec-prefix=<replaceable>PREFIX</replaceable></option></term>
+	<listitem>
+	  <para>If specified, use <replaceable>PREFIX</replaceable>
+	    instead of the installation exec prefix that
+	    <command>snacc</command> was built with when computing the
+	    output for the <option>--cflags</option> and
+	    <option>--libs</option> options.  This option is normally
+	    not needed in &debian;.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--libtool</option></term>
+	<listitem>
+	  <para>If you understand this option, please file a bug
+	    against snacc.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--cflags</option></term>
+	<listitem>
+	  <para>Print the compiler flags that are necessary to compile
+	    a <command>snacc</command> based program.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--libs</option></term>
+	<listitem>
+	  <para>Print the linker flags that are necessary to link a
+	    <command>snacc</command> based program.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--compiler</option></term>
+	<listitem>
+	  <para>Prints the filename of <command>snacc</command>.  On
+	    &debian;, it's <filename>/usr/bin/snacc</filename>.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--asn1specs</option></term>
+	<listitem>
+	  <para>Print the location of the
+	    <command>snacc</command>-specific ASN.1 files.  On
+	    &debian;, it's
+	    <filename>/usr/include/snacc/asn1/</filename>.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>--language=<replaceable>LANG (C or C++)</replaceable></option></term>
+	<listitem>
+
+	  <para>This option determines, wether
+	    <option>--cflags</option> and <option>--libs</option>
+	    print the flags for C or C++.  On &debian; this is
+	    e.g. <filename>/usr/include/snacc/c/</filename> or
+	    <filename>/usr/include/snacc/c++/</filename>.</para>
+	</listitem>
+      </varlistentry>
+      <varlistentry>
+	<term><option>BUFFERTYPE</option></term>
+	<listitem>
+	  <para>This option determines the output of
+	    <option>--cflags</option> and <option>--libs</option>.
+	    <option>BUFFERTYPE</option> must be one of
+	    <replaceable>ebuf</replaceable>,
+	    <replaceable>mbuf</replaceable>,
+	    <replaceable>sbuf</replaceable>, or
+	    <replaceable>tbl</replaceable>.</para>
+	</listitem>
+      </varlistentry>
+    </variablelist>
+  </refsect1>
+  <refsect1>
+    <title>See Also</title>
+
+    <para>snacc (1), mkchdr(1), ptbl(1), pval(1), berdecode(1).</para>
+
+    <para>Please install the snacc-doc package for more
+      information on snacc.</para>
+
+  </refsect1>
+  <refsect1>
+    <title>Author</title>
+
+    <para>This manual page was written by &dhusername; (&dhemail;) for
+      the &debian; system.  Parts of it are taken from the
+      glib-config(1) manual page - I hope that nothing is inaccurate
+      for <command>snacc-config</command>.  Permission is granted to
+      copy, distribute and/or modify this document under the terms of
+      the <acronym>GNU</acronym> General Public License, Version 2
+      or any later version published by the Free Software Foundation.</para>
+
+  </refsect1>
+</refentry>
--- snacc-1.3bbn.orig/debian/rules
+++ snacc-1.3bbn/debian/rules
@@ -0,0 +1,24 @@
+#!/usr/bin/make -f
+
+DEB_DH_ALWAYS_EXCLUDE=.svn
+DEB_INSTALL_DOCS_snacc-doc=doc/*
+DEB_INSTALL_EXAMPLES_libsnacc-dev=snacc-1.3b4/*
+DEB_INSTALL_MANPAGES_snacc=debian/{berdecode,snacc-config}.1
+
+include /usr/share/cdbs/1/rules/debhelper.mk
+include /usr/share/cdbs/1/rules/simple-patchsys.mk
+include /usr/share/cdbs/1/class/autotools.mk
+
+DB2MAN=/usr/share/xml/docbook/stylesheet/nwalsh/manpages/docbook.xsl
+
+post-patches::
+	-mkdir c-lib/{{Ce,e,m,s}buf,tbl} c++-lib/c++
+	autoreconf -fi
+
+build/snacc::
+	cd debian; xsltproc --nonet --novalid $(DB2MAN) berdecode.dbk
+	cd debian; xsltproc --nonet --novalid $(DB2MAN) snacc-config.dbk
+
+clean::
+	rm -rf c-lib/{{Ce,e,m,s}buf,tbl} c++-lib/c++
+
--- snacc-1.3bbn.orig/debian/berdecode.dbk
+++ snacc-1.3bbn/debian/berdecode.dbk
@@ -0,0 +1,107 @@
+<?xml version='1.0' encoding='utf-8'?>
+<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
+"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
+  <!ENTITY dhfirstname "<firstname>W.</firstname>">
+  <!ENTITY dhsurname   "<surname>Borgert</surname>">
+  <!-- Please adjust the date whenever revising the manpage. -->
+  <!ENTITY dhdate      "<date>2000-04-25</date>">
+  <!ENTITY dhsection   "<manvolnum>1</manvolnum>">
+  <!ENTITY dhemail     "<email>debacle@debian.org</email>">
+  <!ENTITY dhusername  "W. Borgert">
+  <!ENTITY dhucpackage "<refentrytitle>berdecode</refentrytitle>">
+  <!ENTITY dhpackage   "berdecode">
+  <!ENTITY debian      "<productname>Debian GNU/Linux</productname>">
+  <!ENTITY gnu         "<acronym>GNU</acronym>">
+]>
+
+<!-- $Id$ -->
+
+<refentry>
+  <refentryinfo>
+    <address>
+      &dhemail;
+    </address>
+    <author>
+      &dhfirstname;
+      &dhsurname;
+    </author>
+    <copyright>
+      <year>2000</year>
+      <holder>&dhusername;</holder>
+    </copyright>
+    &dhdate;
+  </refentryinfo>
+  <refmeta>
+    &dhucpackage;
+
+    &dhsection;
+  </refmeta>
+  <refnamediv>
+    <refname>&dhpackage;</refname>
+
+    <refpurpose>decode BER encoded data</refpurpose>
+  </refnamediv>
+  <refsynopsisdiv>
+    <cmdsynopsis>
+      <command>&dhpackage;</command>
+
+      <arg><option>-s
+      <replaceable>bytestostrip</replaceable></option></arg>
+
+      <arg><option>-strip
+      <replaceable>bytestostrip</replaceable></option></arg>
+
+      <arg><option>-d</option></arg>
+
+      <arg><option>-debug</option></arg>
+
+      <arg><option>-t
+      <replaceable>tablefilename</replaceable></option></arg>
+
+      <arg><option>-table
+      <replaceable>tablefilename</replaceable></option></arg>
+
+      <arg><option>filename</option></arg>
+
+      <arg><option>-</option></arg>
+
+    </cmdsynopsis>
+  </refsynopsisdiv>
+  <refsect1>
+    <title>Description</title>
+
+      <para>This program reads a binary ASN.1 grammar file generated
+        by <command>snacc</command> <option>-T</option> and uses it to
+        decode ASN.1 BER encoded data from files or stdin.</para>
+
+      <para>From every message the first &lt;bytestostrip&gt; bytes
+        (default 2) are skipped.</para>
+
+      <para>Flag <option>-d</option> gives additional information
+        during decoding.</para>
+
+      <para>This manual page was written for the &debian; distribution
+        because the original program does have only a README
+        file.</para>
+
+  </refsect1>
+  <refsect1>
+    <title>See Also</title>
+
+    <para>snacc (1), mkchdr(1), ptbl(1), pval(1),
+      snacc-config(1).</para>
+
+    <para>Please install the snacc-doc package for more
+      information on snacc.</para>
+
+  </refsect1>
+  <refsect1>
+    <title>Author</title>
+
+    <para>This manual page was written by &dhusername; (&dhemail;) for
+      the &debian; system.  Permission is granted to copy, distribute
+      and/or modify this document under the terms of the
+      <acronym>GNU</acronym> General Public License, Version 2
+      or any later version published by the Free Software Foundation.</para>
+  </refsect1>
+</refentry>
--- snacc-1.3bbn.orig/debian/snacc.install
+++ snacc-1.3bbn/debian/snacc.install
@@ -0,0 +1,9 @@
+debian/tmp/usr/bin/berdecode
+debian/tmp/usr/bin/mkchdr
+debian/tmp/usr/bin/ptbl
+debian/tmp/usr/bin/pval
+debian/tmp/usr/bin/snacc
+debian/tmp/usr/bin/snacc-config
+debian/tmp/usr/include/snacc/asn1
+debian/tmp/usr/share/aclocal/snacc.m4
+debian/tmp/usr/share/man/man1
--- snacc-1.3bbn.orig/debian/README.Debian
+++ snacc-1.3bbn/debian/README.Debian
@@ -0,0 +1,65 @@
+snacc for Debian
+----------------
+
+Help appreciated:
+
+1. Snacc is an old-style-ASN.1 compiler, a lot of people even say it's
+   totally obsolete.  I don't think it's reasonable to hack on it to
+   make it compliant with the latest ASN.1 standards.  ASN.1 has
+   changed a lot, has a lot of new features (object information
+   classes, constraints, parameterisation) and additional encoding
+   rules (PER - Packed Encoding Rules, XER - XML Encoding Rules.  The
+   upcoming ECN (encoding control notation) will even give the user
+   complete control over the encoding.  Therefore, a completely new,
+   all-purpose, free ASN.1 compiler is needed.  If you have written
+   one, please drop me a letter - I would be happy to package it for
+   Debian GNU/Linux.
+
+2. The snacc development has split up since 1997:
+
+   2.1 The root-of-all-snacc is by M. Sample and G. Neufeld, later
+       maintained by R. Joop and later by S. Wangnick.  The last
+       version has been called 1.3b4, AFAIK.  The last ChangeLog entry
+       is from 1997-09-16.  I tried to contact the original authors,
+       but never got any sign of life.
+
+   2.2 BBN Technologies changed the build process of this version to
+       use GNU automake and libtool and fixed some things.  The Debian
+       package uses this version, because it builds easily.  The
+       Debian package adds the examples from older snacc versions.
+       Good work, but please update the ChangeLog next time :-) They
+       called their version 1.3 - I renamed it to 1.3bbn, to avoid
+       confusion with the old 1.3 version.  The last ChangeLog entry
+       is from 1997-10-10.  Some people seem to use and enhance this
+       version heavily, e.g.  see bug report #202593 by Kai Henningsen
+       <kai@lisbeth2.intern.cats.ms>.
+
+   2.3 DigitalNet (formerly Getronics Government Solutions (formerly
+       J.G. Van Dyke & Associates, Inc)) changed snacc in parallel:
+       They added support for DER (Distinguished Encoding Rules) and
+       some string types.  Their branch is called eSNACC.
+       Unfortunately - last I checked - they don't use GNU automake
+       and libtool, but some proprietary build techniques (*.dsw and
+       *.dsp files), so this version does not build as cleanly as BBNs
+       under UNIX.  Also, they renamed files, ingnoring the GNU coding
+       standard, e.g. they renamed `ChangeLog', `NEWS', `README' and
+       everything else to all lower-case.  They even renamed all .C
+       files into .cpp.  The latest version is 1.5.1 from 2003-05.
+       But they do not update the ChangeLog, so the last entry is from
+       1997-09-16.  Download it from
+       http://www.digitalnet.com/knowledge/snacc_lib.htm, source:
+       http://www.digitalnet.com/knowledge/snacc_lib/esnacc-1.5.1.tgz.
+
+   2.4 There is also a "Snacc for Java" (by IBM, I think).  I don't
+       know anything about it.
+
+   It would be worthwhile to re-integrate the approaches 2.2 and 2.3.
+   OTOH, it would be a lot of work, better spend with 1., see above.
+
+3. The Debian build of snacc leaves out the ASN.1 tree viewer/editor.
+   If anybody needs it and is able to compile the latest version of
+   the Tcl/Tk tree widget with latest version of Tcl/Tk, please
+   package it.  Or better, write a new one, based on 1. and PyGTK.
+
+ -- W. Borgert <debacle@debian.org>, 2003-08-10T08:15+0000
+
